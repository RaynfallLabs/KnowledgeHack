<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Philosopher's Quest - Knowledge is Power</title>
    <style>
        /* ===== PHILOSOPHER'S QUEST STYLESHEET ===== */

        /* Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Fira+Code:wght@300;400;500;600&display=swap');

        /* CSS Variables */
        :root {
            /* Dark Academia Color Palette */
            --bg-void: #0a0a0f;
            --bg-dark: #12121a;
            --bg-panel: #1a1a28;
            --bg-raised: #242438;
            
            /* Accent Colors */
            --gold-bright: #ffd700;
            --gold-dim: #b8860b;
            --wisdom-purple: #9b59b6;
            --knowledge-blue: #3498db;
            --magic-cyan: #00ffff;
            
            /* Status Colors */
            --health-red: #e74c3c;
            --stamina-green: #27ae60;
            --mana-blue: #2980b9;
            --warning-orange: #f39c12;
            
            /* Text Colors */
            --text-primary: #e8e3d8;
            --text-secondary: #a09890;
            --text-dim: #605850;
            
            /* Borders */
            --border-color: #3a3654;
            --border-gold: #8b7355;
            --glow-color: rgba(255, 215, 0, 0.3);
        }

        /* Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', monospace;
            background: var(--bg-void);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            background-image: 
                radial-gradient(ellipse at top left, rgba(155, 89, 182, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(52, 152, 219, 0.1) 0%, transparent 50%);
        }

        /* Screens */
        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        .screen.active {
            display: flex;
        }

        /* Welcome Screen */
        #welcome-screen {
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
        }

        .welcome-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: var(--gold-bright);
            text-shadow: 0 0 30px var(--glow-color);
            margin-bottom: 10px;
            letter-spacing: 0.2em;
        }

        .game-subtitle {
            font-size: 18px;
            color: var(--wisdom-purple);
            margin-bottom: 40px;
            font-style: italic;
        }

        .welcome-form {
            margin: 30px 0;
        }

        #player-name-input {
            width: 300px;
            padding: 12px 20px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'Fira Code', monospace;
        }

        #player-name-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
        }

        #start-game-btn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 30px rgba(52, 152, 219, 0.3);
        }

        .welcome-info {
            margin-top: 40px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .welcome-info p {
            margin: 10px 0;
        }

        /* Game Screen */
        #game-screen {
            flex-direction: column;
        }

        #game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Game Display */
        #game-display {
            flex: 1;
            background: #000;
            font-family: 'Courier New', 'Fira Code', monospace;
            font-size: 16px;
            font-weight: bold;
            padding: 20px;
            overflow: hidden;
            white-space: pre;
            line-height: 1.0;
            letter-spacing: 0.02em;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* Message Log */
        #message-log {
            height: 180px;
            background: var(--bg-dark);
            border-top: 2px solid var(--border-color);
            padding: 12px;
            overflow-y: auto;
            font-size: 13px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #message-log::-webkit-scrollbar {
            width: 8px;
        }

        #message-log::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #message-log::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .message {
            padding: 4px 8px;
            margin: 2px 0;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .message.info { 
            color: var(--knowledge-blue);
            border-left-color: var(--knowledge-blue);
        }

        .message.success { 
            color: var(--stamina-green);
            border-left-color: var(--stamina-green);
            text-shadow: 0 0 2px currentColor;
        }

        .message.warning { 
            color: var(--warning-orange);
            border-left-color: var(--warning-orange);
        }

        .message.danger { 
            color: var(--health-red);
            border-left-color: var(--health-red);
            font-weight: 600;
            text-shadow: 0 0 3px currentColor;
        }

        .message.action { 
            color: var(--wisdom-purple);
            border-left-color: var(--wisdom-purple);
        }

        .message.loot { 
            color: var(--gold-bright);
            border-left-color: var(--gold-bright);
            text-shadow: 0 0 3px var(--glow-color);
        }

        /* Sidebar */
        #sidebar {
            width: 340px;
            background: linear-gradient(180deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
            padding: 15px;
            overflow-y: auto;
            box-shadow: inset 2px 0 5px rgba(0, 0, 0, 0.3);
        }

        #sidebar::-webkit-scrollbar {
            width: 8px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        /* Stat Groups */
        .stat-group {
            margin-bottom: 20px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .stat-group h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px var(--glow-color);
        }

        /* Stat Bars */
        .stat-bar {
            height: 24px;
            background: linear-gradient(180deg, var(--bg-dark), rgba(0,0,0,0.8));
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin: 8px 0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 11px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.2), transparent);
        }

        .hp-bar { 
            background: linear-gradient(90deg, #8b0000, var(--health-red), #ff6b6b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        .sp-bar { 
            background: linear-gradient(90deg, #1a5c2a, var(--stamina-green), #52c77a);
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
        }

        .mp-bar { 
            background: linear-gradient(90deg, #1a4c7a, var(--mana-blue), var(--knowledge-blue));
            box-shadow: 0 0 20px rgba(41, 128, 185, 0.5);
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 0 3px #000, 0 0 6px #000;
            color: var(--text-primary);
            z-index: 10;
            letter-spacing: 0.05em;
        }

        /* Attributes Display */
        .stat-group div {
            font-size: 13px;
            margin: 4px 0;
            color: var(--text-secondary);
        }

        .stat-group div span {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Status Effects */
        #status-effects span {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: var(--bg-dark);
            border: 1px solid currentColor;
            border-radius: 4px;
            font-size: 11px;
            text-transform: uppercase;
        }

        /* Inventory */
        .inventory-item {
            padding: 4px 8px;
            font-size: 12px;
            margin: 2px 0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .inventory-item:hover {
            background: var(--bg-dark);
            padding-left: 12px;
        }

        .inventory-item.equipped { 
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border-left: 3px solid var(--stamina-green);
        }

        .inventory-item.blessed { 
            color: var(--magic-cyan);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.cursed { 
            color: var(--health-red);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.unidentified { 
            color: var(--text-dim);
            font-style: italic;
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            padding: 12px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
        }

        .controls h4 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .control-line {
            color: var(--text-secondary);
            margin: 4px 0;
            display: flex;
            align-items: center;
        }

        .control-line .key {
            color: var(--knowledge-blue);
            font-weight: 600;
            background: var(--bg-dark);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid var(--border-color);
            min-width: 80px;
            text-align: center;
        }

        /* Quiz Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-raised) 100%);
            border: 2px solid var(--gold-dim);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 50px rgba(255, 215, 0, 0.2),
                0 10px 40px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .quiz-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 28px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 20px var(--glow-color);
        }

        #quiz-subject {
            color: var(--wisdom-purple);
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quiz-timer {
            font-size: 48px;
            font-weight: 600;
            color: var(--stamina-green);
            margin: 20px 0;
            text-shadow: 0 0 10px currentColor;
            font-variant-numeric: tabular-nums;
        }

        .quiz-timer.warning { 
            color: var(--warning-orange);
            animation: pulse 1s infinite;
        }

        .quiz-timer.danger { 
            color: var(--health-red);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .quiz-progress {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 10px;
        }

        .quiz-question {
            font-size: 18px;
            line-height: 1.6;
            margin: 25px 0;
            padding: 20px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .quiz-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin: 10px 0;
            transition: all 0.3s ease;
            font-family: 'Fira Code', monospace;
        }

        .quiz-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .quiz-button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 5px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .quiz-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
        }

        .quiz-feedback {
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { 
                transform: translateX(-20px);
                opacity: 0;
            }
            to { 
                transform: translateX(0);
                opacity: 1;
            }
        }

        .quiz-feedback.correct {
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border: 2px solid var(--stamina-green);
            text-shadow: 0 0 10px currentColor;
        }

        .quiz-feedback.wrong {
            color: var(--health-red);
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid var(--health-red);
            text-shadow: 0 0 10px currentColor;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen" class="screen active">
        <div class="welcome-content">
            <h1 class="game-title">PHILOSOPHER'S QUEST</h1>
            <p class="game-subtitle">Knowledge is Literally Power</p>
            <div class="welcome-form">
                <input type="text" id="player-name-input" placeholder="Enter your name, seeker..." maxlength="20">
                <button id="start-game-btn">Begin Your Quest</button>
            </div>
            <div class="welcome-info">
                <p>Every action requires knowledge.</p>
                <p>Every swing of your sword demands mathematics.</p>
                <p>Every piece of armor requires geography.</p>
                <p>Learn or perish in the depths.</p>
            </div>
        </div>
    </div>

    <!-- Main Game Screen -->
    <div id="game-screen" class="screen">
        <div id="game-container">
            <div id="main-area">
                <div id="game-display"></div>
                <div id="message-log"></div>
            </div>
            <div id="sidebar">
                <!-- Player Stats -->
                <div class="stat-group">
                    <h3>VITALS</h3>
                    <div class="stat-bar">
                        <div class="stat-bar-fill hp-bar" id="hp-bar"></div>
                        <div class="stat-bar-text" id="hp-text">HP: 20/20</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill sp-bar" id="sp-bar"></div>
                        <div class="stat-bar-text" id="sp-text">SP: 100/100</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill mp-bar" id="mp-bar"></div>
                        <div class="stat-bar-text" id="mp-text">MP: 10/10</div>
                    </div>
                </div>
                
                <!-- Attributes -->
                <div class="stat-group">
                    <h3>ATTRIBUTES</h3>
                    <div>STR: <span id="str">10</span> | CON: <span id="con">10</span></div>
                    <div>DEX: <span id="dex">10</span> | INT: <span id="int">10</span></div>
                    <div>WIS: <span id="wis">10</span> | PER: <span id="per">10</span></div>
                </div>
                
                <!-- Status -->
                <div class="stat-group">
                    <h3>STATUS</h3>
                    <div>AC: <span id="ac">10</span> | Level: <span id="dungeon-level">1</span></div>
                    <div>Sight: <span id="sight">5</span> | Timer: <span id="timer">10</span>s</div>
                    <div id="hunger-status"></div>
                    <div id="burden-status"></div>
                    <div id="status-effects"></div>
                </div>

                <!-- Equipment -->
                <div class="stat-group">
                    <h3>EQUIPMENT</h3>
                    <div id="equipment-list">
                        <div class="inventory-item">Nothing equipped</div>
                    </div>
                </div>

                <!-- Inventory -->
                <div class="stat-group">
                    <h3>INVENTORY (<span id="weight">0/50</span>)</h3>
                    <div id="inventory-list">
                        <div class="inventory-item">Empty</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="controls">
                    <h4>CONTROLS</h4>
                    <div class="control-line"><span class="key">↑↓←→/HJKL</span> Move</div>
                    <div class="control-line"><span class="key">,/g</span> Get item</div>
                    <div class="control-line"><span class="key">E</span> Eat food</div>
                    <div class="control-line"><span class="key">c</span> Cook</div>
                    <div class="control-line"><span class="key">I</span> Identify</div>
                    <div class="control-line"><span class="key">./Space</span> Wait</div>
                    <div class="control-line"><span class="key">?</span> Help</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal" class="modal">
        <div class="modal-content">
            <div class="quiz-header">
                <div class="quiz-title" id="quiz-title">Knowledge Challenge</div>
                <div id="quiz-subject">Mathematics</div>
                <div class="quiz-timer" id="quiz-timer">30</div>
                <div class="quiz-progress" id="quiz-progress">Question 1 | Score: 0</div>
            </div>
            <div class="quiz-question" id="quiz-question">Question will appear here</div>
            <div id="quiz-input-area">
                <input type="text" class="quiz-input" id="quiz-answer" placeholder="Type your answer..." autocomplete="off">
                <button class="quiz-button" id="quiz-submit">Submit Answer</button>
            </div>
            <div class="quiz-feedback" id="quiz-feedback" style="display: none;"></div>
        </div>
    </div>

    <script>
        // ===== PHILOSOPHER'S QUEST - COMPLETE GAME =====
        
        // Global game state
        const Game = {
            // Core state
            player: null,
            dungeon: null,
            monsters: [],
            items: [],
            currentLevel: 1,
            turn: 0,
            
            // Display
            display: null,
            messageLog: [],
            maxMessages: 100,
            
            // Quiz state
            activeQuiz: null,
            quizTimer: null,
            quizTimeRemaining: 0,
            
            // Game configuration
            config: {
                mapWidth: 80,
                mapHeight: 25,
                baseHP: 20,
                baseSP: 100,
                baseMP: 10,
                startingWisdom: 10
            }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor(name = "Hero") {
                this.name = name;
                
                // Core attributes
                this.strength = 10;
                this.constitution = 10;
                this.dexterity = 10;
                this.intelligence = 10;
                this.wisdom = 10;
                this.perception = 10;
                
                // Derived stats
                this.maxHp = Game.config.baseHP + Math.floor((this.constitution - 10) / 2);
                this.hp = this.maxHp;
                this.maxSp = Game.config.baseSP + (this.constitution - 10) * 2;
                this.sp = this.maxSp;
                this.maxMp = Game.config.baseMP + Math.floor((this.intelligence - 10) / 2);
                this.mp = this.maxMp;
                
                // Position
                this.x = 0;
                this.y = 0;
                
                // Equipment slots
                this.equipped = {
                    weapon: null,
                    armor: {
                        head: null,
                        body: null,
                        hands: null,
                        legs: null,
                        cloak: null,
                        shirt: null
                    },
                    accessories: {
                        leftRing: null,
                        rightRing: null,
                        amulet: null
                    }
                };
                
                // Inventory
                this.inventory = [];
                this.maxCarry = 50 + this.strength * 2;
                this.currentWeight = 0;
                
                // Status flags
                this.statusFlags = {
                    isStarving: false,
                    isConfused: false,
                    isBlind: false,
                    isStunned: false,
                    isHallucinating: false,
                    isParalyzed: false,
                    isSick: false,
                    isPoisoned: false,
                    isStoned: false,
                    isSlimed: false,
                    isLevitating: false,
                    isFlying: false,
                    isInvisible: false
                };
                
                // Inventory letter assignment
                this.nextInventoryLetter = 'a';
            }
            
            getAC() {
                let ac = 10 + Math.floor((this.dexterity - 10) / 2);
                Object.values(this.equipped.armor).forEach(armor => {
                    if (armor) ac += armor.acBonus || 0;
                });
                return ac;
            }
            
            getSightRadius() {
                return 3 + Math.floor(this.perception / 5);
            }
            
            getQuizTimer() {
                return Math.max(10, this.wisdom);
            }
            
            getHungerStatus() {
                const percent = this.sp / this.maxSp;
                if (this.sp <= 0) return "Starving";
                if (percent <= 0.1) return "Fainting";
                if (percent <= 0.2) return "Weak";
                if (percent <= 0.3) return "Hungry";
                if (percent >= 1.2) return "Satiated";
                return "";
            }
            
            getBurdenStatus() {
                const percent = (this.currentWeight / this.maxCarry) * 100;
                if (percent > 300) return "Overloaded";
                if (percent > 200) return "Overtaxed";
                if (percent > 150) return "Strained";
                if (percent > 100) return "Stressed";
                if (percent > 75) return "Burdened";
                return "";
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    Game.gameOver("You have died!");
                }
            }
            
            spendSP(amount = 1) {
                this.sp -= amount;
                if (this.sp <= 0) {
                    this.sp = 0;
                    this.statusFlags.isStarving = true;
                    this.takeDamage(1);
                    Game.addMessage("You're starving! You take damage!", 'danger');
                } else {
                    this.statusFlags.isStarving = false;
                }
            }
            
            restoreSP(amount) {
                this.sp = Math.min(this.maxSp, this.sp + amount);
                if (this.sp > 0) this.statusFlags.isStarving = false;
            }
            
            addToInventory(item) {
                if (this.currentWeight + (item.weight || 1) > this.maxCarry) {
                    Game.addMessage("You can't carry that much weight!", 'warning');
                    return false;
                }
                
                // Assign inventory letter
                item.letter = this.nextInventoryLetter;
                this.nextInventoryLetter = String.fromCharCode(this.nextInventoryLetter.charCodeAt(0) + 1);
                if (this.nextInventoryLetter > 'z') this.nextInventoryLetter = 'A';
                
                this.inventory.push(item);
                this.currentWeight += item.weight || 1;
                return true;
            }
            
            removeFromInventory(item) {
                const index = this.inventory.indexOf(item);
                if (index > -1) {
                    this.inventory.splice(index, 1);
                    this.currentWeight -= item.weight || 1;
                    return true;
                }
                return false;
            }
        }
        
        // ===== FOV (FIELD OF VIEW) =====
        // Shadowcasting algorithm for proper line of sight
        Game.calculateFOV = function() {
            const fov = [];
            for (let y = 0; y < Game.config.mapHeight; y++) {
                fov[y] = [];
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    fov[y][x] = false;
                }
            }
            
            const px = Game.player.x;
            const py = Game.player.y;
            const radius = Game.player.getSightRadius();
            
            // Player can always see themselves
            if (py >= 0 && py < fov.length && px >= 0 && px < fov[0].length) {
                fov[py][px] = true;
            }
            
            // Cast light in 8 octants
            for (let octant = 0; octant < 8; octant++) {
                Game.castLight(fov, px, py, radius, 1, 1.0, 0.0, 
                    Game.multipliers[0][octant], Game.multipliers[1][octant],
                    Game.multipliers[2][octant], Game.multipliers[3][octant]);
            }
            
            return fov;
        };
        
        // Shadowcasting octant multipliers
        Game.multipliers = [
            [1, 0, 0, -1, -1, 0, 0, 1],
            [0, 1, -1, 0, 0, -1, 1, 0],
            [0, 1, 1, 0, 0, -1, -1, 0],
            [1, 0, 0, 1, -1, 0, 0, -1]
        ];
        
        Game.castLight = function(fov, cx, cy, radius, row, start, end, xx, xy, yx, yy) {
            if (start < end) return;
            
            const radius2 = radius * radius;
            
            for (let j = row; j <= radius; j++) {
                let dx = -j - 1;
                let dy = -j;
                let blocked = false;
                let newStart = start;
                
                while (dx <= 0) {
                    dx++;
                    
                    const X = cx + dx * xx + dy * xy;
                    const Y = cy + dx * yx + dy * yy;
                    
                    const lSlope = (dx - 0.5) / (dy + 0.5);
                    const rSlope = (dx + 0.5) / (dy - 0.5);
                    
                    if (newStart < rSlope) continue;
                    if (end > lSlope) break;
                    
                    if (dx * dx + dy * dy < radius2) {
                        if (Y >= 0 && Y < fov.length && X >= 0 && X < fov[0].length) {
                            fov[Y][X] = true;
                        }
                    }
                    
                    if (blocked) {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#') {
                            newStart = rSlope;
                            continue;
                        } else {
                            blocked = false;
                            start = newStart;
                        }
                    } else {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#' && j < radius) {
                            blocked = true;
                            Game.castLight(fov, cx, cy, radius, j + 1, start, lSlope,
                                xx, xy, yx, yy);
                            newStart = rSlope;
                        }
                    }
                }
                
                if (blocked) break;
            }
        };

        // ===== MONSTER CLASS =====
        class Monster {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                
                // Default stats for basic monsters
                const monsterTypes = {
                    'goblin': { symbol: 'g', hp: 5, damage: 2, color: '#8b8' },
                    'orc': { symbol: 'o', hp: 10, damage: 3, color: '#a82' },
                    'skeleton': { symbol: 's', hp: 8, damage: 2, color: '#ddd' },
                    'rat': { symbol: 'r', hp: 3, damage: 1, color: '#888' },
                    'kobold': { symbol: 'k', hp: 4, damage: 2, color: '#88f' }
                };
                
                const data = monsterTypes[type] || monsterTypes['goblin'];
                this.name = type;
                this.symbol = data.symbol;
                this.color = data.color;
                this.maxHp = data.hp;
                this.hp = this.maxHp;
                this.damage = data.damage;
                this.dead = false;
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                }
            }
            
            move() {
                if (this.dead) return;
                
                // Simple AI: move toward player if within 10 tiles
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                if (distance > 10) return; // Too far, don't chase
                
                let moveX = 0, moveY = 0;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    moveY = dy > 0 ? 1 : -1;
                }
                
                const newX = this.x + moveX;
                const newY = this.y + moveY;
                
                // Check if attacking player
                if (newX === Game.player.x && newY === Game.player.y) {
                    this.attack();
                } else if (Game.canMoveTo(newX, newY) && !Game.getMonsterAt(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                }
            }
            
            attack() {
                Game.player.takeDamage(this.damage);
                Game.addMessage(`The ${this.name} hits you for ${this.damage} damage!`, 'danger');
            }
        }

        // ===== DUNGEON GENERATION =====
        function generateDungeon(width, height) {
            const dungeon = [];
            
            // Initialize with walls
            for (let y = 0; y < height; y++) {
                dungeon[y] = [];
                for (let x = 0; x < width; x++) {
                    dungeon[y][x] = '#';
                }
            }
            
            // Generate rooms
            const rooms = [];
            const numRooms = 5 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < numRooms; i++) {
                const roomWidth = 5 + Math.floor(Math.random() * 10);
                const roomHeight = 5 + Math.floor(Math.random() * 6);
                const roomX = 1 + Math.floor(Math.random() * (width - roomWidth - 2));
                const roomY = 1 + Math.floor(Math.random() * (height - roomHeight - 2));
                
                // Carve room
                for (let y = roomY; y < roomY + roomHeight; y++) {
                    for (let x = roomX; x < roomX + roomWidth; x++) {
                        dungeon[y][x] = '.';
                    }
                }
                
                rooms.push({
                    x: roomX + Math.floor(roomWidth / 2),
                    y: roomY + Math.floor(roomHeight / 2),
                    width: roomWidth,
                    height: roomHeight
                });
            }
            
            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                
                // Horizontal then vertical
                const startX = Math.min(room1.x, room2.x);
                const endX = Math.max(room1.x, room2.x);
                for (let x = startX; x <= endX; x++) {
                    dungeon[room1.y][x] = '.';
                }
                
                const startY = Math.min(room1.y, room2.y);
                const endY = Math.max(room1.y, room2.y);
                for (let y = startY; y <= endY; y++) {
                    dungeon[y][room2.x] = '.';
                }
            }
            
            // Place player in first room
            if (rooms.length > 0) {
                Game.player.x = rooms[0].x;
                Game.player.y = rooms[0].y;
            }
            
            // Place stairs in last room
            if (rooms.length > 1) {
                const lastRoom = rooms[rooms.length - 1];
                dungeon[lastRoom.y][lastRoom.x] = '>';
            }
            
            // Spawn monsters
            Game.monsters = [];
            const monsterTypes = ['goblin', 'rat', 'kobold', 'orc', 'skeleton'];
            const numMonsters = 3 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < numMonsters && i < rooms.length - 1; i++) {
                const room = rooms[1 + i]; // Skip first room (player spawn)
                const type = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
                const x = room.x - 2 + Math.floor(Math.random() * 5);
                const y = room.y - 2 + Math.floor(Math.random() * 5);
                
                if (dungeon[y][x] === '.') {
                    Game.monsters.push(new Monster(type, x, y));
                }
            }
            
            // Spawn items
            Game.items = [];
            const itemTypes = [
                { type: 'food', name: 'ration', symbol: '%', weight: 1 },
                { type: 'weapon', name: 'dagger', symbol: ')', weight: 3 },
                { type: 'armor', name: 'leather armor', symbol: '[', weight: 8 },
                { type: 'potion', name: 'healing potion', symbol: '!', weight: 1 }
            ];
            
            const numItems = 2 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numItems; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const x = room.x - 2 + Math.floor(Math.random() * 5);
                const y = room.y - 2 + Math.floor(Math.random() * 5);
                
                if (dungeon[y][x] === '.') {
                    const template = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                    Game.items.push({
                        ...template,
                        x: x,
                        y: y,
                        identified: false
                    });
                }
            }
            
            return dungeon;
        }

        // ===== RENDERING =====
        function render() {
            if (!Game.display || !Game.dungeon || !Game.player) return;
            
            // Calculate field of view
            const fov = Game.calculateFOV();
            
            // Build display with HTML for colors
            let displayHTML = '';
            
            for (let y = 0; y < Game.config.mapHeight; y++) {
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    let char = ' ';
                    let color = '#222'; // Dark gray for unseen
                    
                    // Only render if in FOV
                    if (!fov[y] || !fov[y][x]) {
                        // Show remembered walls in dark gray
                        if (Game.remembered && Game.remembered[y] && Game.remembered[y][x] === '#') {
                            char = '#';
                            color = '#333';
                        } else {
                            char = ' ';
                        }
                    } else {
                        // Remember terrain
                        if (!Game.remembered) Game.remembered = [];
                        if (!Game.remembered[y]) Game.remembered[y] = [];
                        if (Game.dungeon[y] && Game.dungeon[y][x]) {
                            Game.remembered[y][x] = Game.dungeon[y][x];
                        }
                        
                        // Player
                        if (x === Game.player.x && y === Game.player.y) {
                            char = '@';
                            color = '#fff'; // White for player
                        }
                        // Monsters
                        else {
                            let hasMonster = false;
                            for (const monster of Game.monsters) {
                                if (!monster.dead && monster.x === x && monster.y === y) {
                                    char = monster.symbol;
                                    color = monster.color;
                                    hasMonster = true;
                                    break;
                                }
                            }
                            
                            if (!hasMonster) {
                                // Items
                                let hasItem = false;
                                for (const item of Game.items) {
                                    if (item.x === x && item.y === y) {
                                        char = item.symbol;
                                        // Item colors
                                        switch(item.type) {
                                            case 'food':
                                            case 'corpse':
                                                color = '#8b4513'; // Brown
                                                break;
                                            case 'weapon':
                                                color = '#c0c0c0'; // Silver
                                                break;
                                            case 'armor':
                                                color = '#4682b4'; // Steel blue
                                                break;
                                            case 'potion':
                                                color = '#ff1493'; // Deep pink
                                                break;
                                            default:
                                                color = '#ffd700'; // Gold
                                        }
                                        hasItem = true;
                                        break;
                                    }
                                }
                                
                                if (!hasItem) {
                                    // Terrain
                                    if (Game.dungeon[y] && Game.dungeon[y][x]) {
                                        char = Game.dungeon[y][x];
                                        // Terrain colors
                                        switch(char) {
                                            case '#':
                                                color = '#888'; // Light gray walls
                                                break;
                                            case '.':
                                                color = '#666'; // Dark gray floor
                                                break;
                                            case '>':
                                                color = '#ff0'; // Yellow stairs
                                                break;
                                            case '+':
                                                color = '#8b4513'; // Brown door
                                                break;
                                            default:
                                                color = '#666';
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    displayHTML += `<span style="color:${color}">${char}</span>`;
                }
                displayHTML += '\n';
            }
            
            Game.display.innerHTML = displayHTML;
            updateUI();
        }

        // ===== UI UPDATES =====
        function updateUI() {
            const player = Game.player;
            if (!player) return;
            
            // Update bars
            document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('hp-text').textContent = `HP: ${player.hp}/${player.maxHp}`;
            
            document.getElementById('sp-bar').style.width = (player.sp / player.maxSp * 100) + '%';
            document.getElementById('sp-text').textContent = `SP: ${player.sp}/${player.maxSp}`;
            
            document.getElementById('mp-bar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mp-text').textContent = `MP: ${player.mp}/${player.maxMp}`;
            
            // Update attributes
            document.getElementById('str').textContent = player.strength;
            document.getElementById('con').textContent = player.constitution;
            document.getElementById('dex').textContent = player.dexterity;
            document.getElementById('int').textContent = player.intelligence;
            document.getElementById('wis').textContent = player.wisdom;
            document.getElementById('per').textContent = player.perception;
            
            // Update status
            document.getElementById('ac').textContent = player.getAC();
            document.getElementById('sight').textContent = player.getSightRadius();
            document.getElementById('timer').textContent = player.getQuizTimer();
            document.getElementById('dungeon-level').textContent = Game.currentLevel;
            
            // Hunger status
            const hungerStatus = player.getHungerStatus();
            document.getElementById('hunger-status').textContent = hungerStatus;
            
            // Burden status
            const burdenStatus = player.getBurdenStatus();
            document.getElementById('burden-status').textContent = burdenStatus;
            
            // Weight
            document.getElementById('weight').textContent = `${player.currentWeight}/${player.maxCarry}`;
            
            // Inventory
            const invList = document.getElementById('inventory-list');
            if (player.inventory.length === 0) {
                invList.innerHTML = '<div class="inventory-item">Empty</div>';
            } else {
                invList.innerHTML = player.inventory.map(item => 
                    `<div class="inventory-item">${item.letter}) ${item.name}${item.identified ? '' : ' (?)'}</div>`
                ).join('');
            }
        }

        // ===== MESSAGE LOG =====
        Game.addMessage = function(text, type = 'info') {
            const messageLog = document.getElementById('message-log');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            
            messageLog.appendChild(message);
            messageLog.scrollTop = messageLog.scrollHeight;
            
            // Limit messages
            while (messageLog.children.length > Game.maxMessages) {
                messageLog.removeChild(messageLog.firstChild);
            }
        };

        // ===== INPUT HANDLING =====
        Game.handleKeyPress = function(e) {
            // Don't handle input during quiz
            if (Game.activeQuiz) return;
            
            let dx = 0, dy = 0;
            
            // Movement keys
            switch(e.key) {
                case 'ArrowUp':
                case 'k': dy = -1; break;
                case 'ArrowDown':
                case 'j': dy = 1; break;
                case 'ArrowLeft':
                case 'h': dx = -1; break;
                case 'ArrowRight':
                case 'l': dx = 1; break;
                case 'y': dx = -1; dy = -1; break;
                case 'u': dx = 1; dy = -1; break;
                case 'b': dx = -1; dy = 1; break;
                case 'n': dx = 1; dy = 1; break;
                
                // Actions
                case ',':
                case 'g':
                    Game.pickupItem();
                    Game.processTurn();
                    return;
                case 'E':
                    Game.eatFood();
                    Game.processTurn();
                    return;
                case '.':
                case ' ':
                    Game.addMessage("You wait.", 'info');
                    Game.player.spendSP(1);
                    Game.processTurn();
                    return;
                case '>':
                    if (Game.dungeon[Game.player.y][Game.player.x] === '>') {
                        Game.nextLevel();
                    }
                    return;
                case '?':
                    Game.showHelp();
                    return;
            }
            
            // Process movement
            if (dx !== 0 || dy !== 0) {
                Game.movePlayer(dx, dy);
                e.preventDefault();
            }
        };

        Game.movePlayer = function(dx, dy) {
            const player = Game.player;
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Check for monster
            const monster = Game.getMonsterAt(newX, newY);
            if (monster && !monster.dead) {
                Game.playerAttack(monster);
                return;
            }
            
            // Check if can move
            if (!Game.canMoveTo(newX, newY)) {
                Game.addMessage("You can't move there!", 'warning');
                return;
            }
            
            // Move player
            player.x = newX;
            player.y = newY;
            player.spendSP(1);
            
            // Check for stairs
            if (Game.dungeon[newY][newX] === '>') {
                Game.addMessage("You see stairs leading down. Press > to descend.", 'info');
            }
            
            Game.processTurn();
        };

        Game.canMoveTo = function(x, y) {
            if (y < 0 || y >= Game.dungeon.length) return false;
            if (x < 0 || x >= Game.dungeon[y].length) return false;
            return Game.dungeon[y][x] !== '#';
        };

        Game.getMonsterAt = function(x, y) {
            return Game.monsters.find(m => !m.dead && m.x === x && m.y === y);
        };

        Game.processTurn = function() {
            // Move monsters
            Game.monsters.forEach(m => m.move());
            
            // Increment turn
            Game.turn++;
            
            // Render
            render();
        };

        Game.playerAttack = function(monster) {
            // For now, simple attack without quiz
            const damage = 2 + Math.floor(Math.random() * 4);
            monster.takeDamage(damage);
            Game.addMessage(`You hit the ${monster.name} for ${damage} damage!`, 'success');
            
            if (monster.dead) {
                Game.addMessage(`The ${monster.name} dies!`, 'success');
                Game.dropCorpse(monster);
            }
            
            Game.processTurn();
        };

        Game.dropCorpse = function(monster) {
            Game.items.push({
                x: monster.x,
                y: monster.y,
                type: 'corpse',
                name: `${monster.name} corpse`,
                symbol: '%',
                weight: 10
            });
        };

        Game.pickupItem = function() {
            const player = Game.player;
            const itemsHere = Game.items.filter(i => i.x === player.x && i.y === player.y);
            
            if (itemsHere.length === 0) {
                Game.addMessage("There's nothing here to pick up.", 'info');
                return;
            }
            
            const item = itemsHere[0];
            if (player.addToInventory(item)) {
                Game.items = Game.items.filter(i => i !== item);
                Game.addMessage(`You pick up the ${item.name}.`, 'action');
            }
        };

        Game.eatFood = function() {
            const player = Game.player;
            const food = player.inventory.find(i => i.type === 'food' || i.type === 'corpse');
            
            if (!food) {
                Game.addMessage("You have no food to eat.", 'warning');
                return;
            }
            
            player.removeFromInventory(food);
            const spRestore = 20 + Math.floor(Math.random() * 20);
            player.restoreSP(spRestore);
            Game.addMessage(`You eat the ${food.name} and restore ${spRestore} SP.`, 'success');
        };

        Game.nextLevel = function() {
            Game.currentLevel++;
            Game.addMessage(`You descend to level ${Game.currentLevel}...`, 'action');
            Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);
            render();
        };

        Game.showHelp = function() {
            Game.addMessage("=== CONTROLS ===", 'info');
            Game.addMessage("Movement: Arrow keys or HJKLYUBN", 'info');
            Game.addMessage("Get item: , or g", 'info');
            Game.addMessage("Eat: E | Wait: . or Space", 'info');
            Game.addMessage("Descend stairs: >", 'info');
        };

        Game.gameOver = function(message) {
            Game.addMessage("=== GAME OVER ===", 'danger');
            Game.addMessage(message, 'danger');
            Game.addMessage(`You survived ${Game.turn} turns and reached level ${Game.currentLevel}.`, 'info');
            document.removeEventListener('keydown', Game.handleKeyPress);
        };

        // ===== INITIALIZATION =====
        Game.init = function() {
            // Setup welcome screen
            const nameInput = document.getElementById('player-name-input');
            const startBtn = document.getElementById('start-game-btn');
            
            nameInput.focus();
            
            // Handle Enter key on name input
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    Game.startGame();
                }
            });
            
            startBtn.addEventListener('click', Game.startGame);
        };

        Game.startGame = function() {
            const nameInput = document.getElementById('player-name-input');
            const playerName = nameInput.value.trim() || 'Hero';
            
            // Hide welcome, show game
            document.getElementById('welcome-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            // Get display element
            Game.display = document.getElementById('game-display');
            
            // Create player
            Game.player = new Player(playerName);
            
            // Generate first dungeon
            Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);
            
            // Setup input
            document.addEventListener('keydown', Game.handleKeyPress);
            
            // Initial messages
            Game.addMessage(`Welcome, ${playerName}, to the Philosopher's Quest!`, 'success');
            Game.addMessage("Knowledge is power. Every action requires learning.", 'info');
            Game.addMessage("Press ? for help.", 'info');
            
            // Initial render
            render();
        };

        // Start when page loads
        window.addEventListener('load', Game.init);
    </script>
</body>
</html>