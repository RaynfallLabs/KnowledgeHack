<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Philosopher's Quest - Knowledge is Power</title>
    <style>
        /* ===== PHILOSOPHER'S QUEST STYLESHEET ===== */

        /* Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Fira+Code:wght@300;400;500;600&display=swap');

        /* CSS Variables */
        :root {
            /* Dark Academia Color Palette */
            --bg-void: #0a0a0f;
            --bg-dark: #12121a;
            --bg-panel: #1a1a28;
            --bg-raised: #242438;
            
            /* Accent Colors */
            --gold-bright: #ffd700;
            --gold-dim: #b8860b;
            --wisdom-purple: #9b59b6;
            --knowledge-blue: #3498db;
            --magic-cyan: #00ffff;
            
            /* Status Colors */
            --health-red: #e74c3c;
            --stamina-green: #27ae60;
            --mana-blue: #2980b9;
            --warning-orange: #f39c12;
            
            /* Text Colors */
            --text-primary: #e8e3d8;
            --text-secondary: #a09890;
            --text-dim: #605850;
            
            /* Borders */
            --border-color: #3a3654;
            --border-gold: #8b7355;
            --glow-color: rgba(255, 215, 0, 0.3);
        }

        /* Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', monospace;
            background: var(--bg-void);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            background-image: 
                radial-gradient(ellipse at top left, rgba(155, 89, 182, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(52, 152, 219, 0.1) 0%, transparent 50%);
        }

        /* Screens */
        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        .screen.active {
            display: flex;
        }

        /* Welcome Screen */
        #welcome-screen {
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
        }

        .welcome-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: var(--gold-bright);
            text-shadow: 0 0 30px var(--glow-color);
            margin-bottom: 10px;
            letter-spacing: 0.2em;
        }

        .game-subtitle {
            font-size: 18px;
            color: var(--wisdom-purple);
            margin-bottom: 40px;
            font-style: italic;
        }

        .welcome-form {
            margin: 30px 0;
        }

        #player-name-input {
            width: 300px;
            padding: 12px 20px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'Fira Code', monospace;
        }

        #player-name-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
        }

        #start-game-btn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 30px rgba(52, 152, 219, 0.3);
        }

        .welcome-info {
            margin-top: 40px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .welcome-info p {
            margin: 10px 0;
        }

        /* Game Screen */
        #game-screen {
            flex-direction: column;
        }

        #game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Game Display */
        #game-display {
            flex: 1;
            background: #000;
            font-family: 'Courier New', 'Fira Code', monospace;
            font-size: 16px;
            font-weight: bold;
            padding: 20px;
            overflow: hidden;
            white-space: pre;
            line-height: 1.0;
            letter-spacing: 0.02em;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* Message Log */
        #message-log {
            height: 250px;  /* Increased from 180px */
            background: var(--bg-dark);
            border-top: 2px solid var(--border-color);
            padding: 12px;
            overflow-y: auto;
            font-size: 13px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #message-log::-webkit-scrollbar {
            width: 8px;
        }

        #message-log::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #message-log::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .message {
            padding: 4px 8px;
            margin: 2px 0;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .message.info { 
            color: var(--knowledge-blue);
            border-left-color: var(--knowledge-blue);
        }

        .message.success { 
            color: var(--stamina-green);
            border-left-color: var(--stamina-green);
            text-shadow: 0 0 2px currentColor;
        }

        .message.warning { 
            color: var(--warning-orange);
            border-left-color: var(--warning-orange);
        }

        .message.danger { 
            color: var(--health-red);
            border-left-color: var(--health-red);
            font-weight: 600;
            text-shadow: 0 0 3px currentColor;
        }

        .message.action { 
            color: var(--wisdom-purple);
            border-left-color: var(--wisdom-purple);
        }

        .message.loot { 
            color: var(--gold-bright);
            border-left-color: var(--gold-bright);
            text-shadow: 0 0 3px var(--glow-color);
        }

        /* Sidebar */
        #sidebar {
            width: 340px;
            background: linear-gradient(180deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
            padding: 15px;
            overflow-y: auto;
            box-shadow: inset 2px 0 5px rgba(0, 0, 0, 0.3);
        }

        #sidebar::-webkit-scrollbar {
            width: 8px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        /* Stat Groups */
        .stat-group {
            margin-bottom: 20px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .stat-group h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px var(--glow-color);
        }

        /* Stat Bars */
        .stat-bar {
            height: 24px;
            background: linear-gradient(180deg, var(--bg-dark), rgba(0,0,0,0.8));
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin: 8px 0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 11px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.2), transparent);
        }

        .hp-bar { 
            background: linear-gradient(90deg, #8b0000, var(--health-red), #ff6b6b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        .sp-bar { 
            background: linear-gradient(90deg, #1a5c2a, var(--stamina-green), #52c77a);
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
        }

        .mp-bar { 
            background: linear-gradient(90deg, #1a4c7a, var(--mana-blue), var(--knowledge-blue));
            box-shadow: 0 0 20px rgba(41, 128, 185, 0.5);
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 0 3px #000, 0 0 6px #000;
            color: var(--text-primary);
            z-index: 10;
            letter-spacing: 0.05em;
        }

        /* Attributes Display */
        .stat-group div {
            font-size: 13px;
            margin: 4px 0;
            color: var(--text-secondary);
        }

        .stat-group div span {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Status Effects */
        #status-effects span {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: var(--bg-dark);
            border: 1px solid currentColor;
            border-radius: 4px;
            font-size: 11px;
            text-transform: uppercase;
        }

        /* Inventory */
        .inventory-item {
            padding: 4px 8px;
            font-size: 12px;
            margin: 2px 0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .inventory-item:hover {
            background: var(--bg-dark);
            padding-left: 12px;
        }

        .inventory-item.equipped { 
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border-left: 3px solid var(--stamina-green);
        }

        .inventory-item.blessed { 
            color: var(--magic-cyan);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.cursed { 
            color: var(--health-red);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.unidentified { 
            color: var(--text-dim);
            font-style: italic;
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            padding: 12px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
        }

        .controls h4 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .control-line {
            color: var(--text-secondary);
            margin: 4px 0;
            display: flex;
            align-items: center;
        }

        .control-line .key {
            color: var(--knowledge-blue);
            font-weight: 600;
            background: var(--bg-dark);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid var(--border-color);
            min-width: 80px;
            text-align: center;
        }

        /* Quiz Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-raised) 100%);
            border: 2px solid var(--gold-dim);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 50px rgba(255, 215, 0, 0.2),
                0 10px 40px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .quiz-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 28px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 20px var(--glow-color);
        }

        #quiz-subject {
            color: var(--wisdom-purple);
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quiz-timer {
            font-size: 48px;
            font-weight: 600;
            color: var(--stamina-green);
            margin: 20px 0;
            text-shadow: 0 0 10px currentColor;
            font-variant-numeric: tabular-nums;
        }

        .quiz-timer.warning { 
            color: var(--warning-orange);
            animation: pulse 1s infinite;
        }

        .quiz-timer.danger { 
            color: var(--health-red);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .quiz-progress {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 10px;
        }

        .quiz-question {
            font-size: 18px;
            line-height: 1.6;
            margin: 25px 0;
            padding: 20px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .quiz-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin: 10px 0;
            transition: all 0.3s ease;
            font-family: 'Fira Code', monospace;
        }

        .quiz-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .quiz-button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 5px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .quiz-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
        }

        /* Multiple Choice Buttons */
        .quiz-choice-button {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-family: 'Fira Code', monospace;
        }
        
        .quiz-choice-button:hover {
            background: var(--bg-raised);
            border-color: var(--knowledge-blue);
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.2);
        }
        
        .quiz-choice-button.selected {
            background: linear-gradient(135deg, var(--bg-raised), var(--bg-dark));
            border-color: var(--gold-bright);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .choice-letter {
            display: inline-block;
            width: 35px;
            height: 35px;
            background: var(--wisdom-purple);
            color: var(--text-primary);
            border-radius: 50%;
            text-align: center;
            line-height: 35px;
            font-weight: 600;
            margin-right: 15px;
            font-size: 18px;
        }
        
        .quiz-choice-button.selected .choice-letter {
            background: var(--gold-bright);
            color: var(--bg-dark);
        }
        
        .choice-text {
            flex: 1;
            font-size: 15px;
        }

        .quiz-feedback {
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { 
                transform: translateX(-20px);
                opacity: 0;
            }
            to { 
                transform: translateX(0);
                opacity: 1;
            }
        }

        .quiz-feedback.correct {
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border: 2px solid var(--stamina-green);
            text-shadow: 0 0 10px currentColor;
        }

        .quiz-feedback.wrong {
            color: var(--health-red);
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid var(--health-red);
            text-shadow: 0 0 10px currentColor;
        }

        /* Cooking Modal Styles */
        .ingredient-button {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            font-family: 'Fira Code', monospace;
            transition: all 0.3s ease;
        }

        .ingredient-button:hover {
            background: var(--bg-raised);
            border-color: var(--knowledge-blue);
            transform: translateX(5px);
        }

        .ingredient-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

         /* Help Modal Styles */
        .help-command {
            padding: 4px 0;
            color: var(--text-primary);
            font-size: 14px;
        }

        .help-command .key {
            display: inline-block;
            min-width: 100px;
            color: var(--knowledge-blue);
            font-weight: 600;
            background: var(--bg-dark);
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .score-line {
            padding: 4px 0;
            color: var(--text-secondary);
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .score-line span {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Universal Menu System */
        .universal-menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-raised) 100%);
            border: 2px solid var(--gold-dim);
            border-radius: 12px;
            box-shadow: 
                0 0 50px rgba(255, 215, 0, 0.2),
                0 10px 40px rgba(0, 0, 0, 0.8);
            animation: menuSlideIn 0.3s ease;
            max-width: 600px;
            min-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .universal-menu.active {
            display: flex;
        }
        
        @keyframes menuSlideIn {
            from { 
                opacity: 0;
                transform: translate(-50%, -45%);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .menu-content {
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .menu-header {
            padding: 20px 30px;
            border-bottom: 2px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .menu-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 20px var(--glow-color);
            text-align: center;
        }
        
        .menu-subtitle {
            color: var(--text-secondary);
            font-size: 14px;
            text-align: center;
            margin-top: 8px;
        }
        
        .menu-items {
            flex: 1;
            overflow-y: auto;
            padding: 15px 0;
            scrollbar-width: none;
        }
        
        .menu-items::-webkit-scrollbar {
            display: none;
        }
        
        .menu-item {
            padding: 12px 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .menu-item:hover:not(.disabled) {
            background: rgba(52, 152, 219, 0.1);
            padding-left: 35px;
        }
        
        .menu-item.selected {
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid var(--gold-bright);
        }
        
        .menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .menu-letter {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: var(--wisdom-purple);
            color: var(--text-primary);
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .menu-item:hover:not(.disabled) .menu-letter {
            background: var(--knowledge-blue);
            transform: scale(1.1);
        }
        
        .menu-item.selected .menu-letter {
            background: var(--gold-bright);
            color: var(--bg-dark);
        }
        
        .menu-text {
            flex: 1;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 500;
        }
        
        .menu-description {
            color: var(--text-secondary);
            font-size: 12px;
            font-style: italic;
        }
        
        .menu-footer {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-secondary);
            font-size: 13px;
            background: rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen" class="screen active">
        <div class="welcome-content">
            <h1 class="game-title">PHILOSOPHER'S QUEST</h1>
            <p class="game-subtitle">Knowledge is Literally Power</p>
            <div class="welcome-form">
                <input type="text" id="player-name-input" placeholder="Enter your name, seeker..." maxlength="20">
                <button id="start-game-btn">Begin Your Quest</button>
            </div>
            <div class="welcome-info">
                <p>Every action requires knowledge.</p>
                <p>Every swing of your sword demands mathematics.</p>
                <p>Every piece of armor requires geography.</p>
                <p>Learn or perish in the depths.</p>
            </div>
        </div>
    </div>

    <!-- Main Game Screen -->
    <div id="game-screen" class="screen">
        <div id="game-container">
            <div id="main-area">
                <div id="game-display"></div>
                <div id="message-log"></div>
            </div>
            <div id="sidebar">
                <!-- Player Stats -->
                <div class="stat-group">
                    <h3>VITALS</h3>
                    <div class="stat-bar">
                        <div class="stat-bar-fill hp-bar" id="hp-bar"></div>
                        <div class="stat-bar-text" id="hp-text">HP: 20/20</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill sp-bar" id="sp-bar"></div>
                        <div class="stat-bar-text" id="sp-text">SP: 100/100</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill mp-bar" id="mp-bar"></div>
                        <div class="stat-bar-text" id="mp-text">MP: 10/10</div>
                    </div>
                </div>
                
                <!-- Attributes -->
                <div class="stat-group">
                    <h3>ATTRIBUTES</h3>
                    <div>STR: <span id="str">10</span> | CON: <span id="con">10</span></div>
                    <div>DEX: <span id="dex">10</span> | INT: <span id="int">10</span></div>
                    <div>WIS: <span id="wis">10</span> | PER: <span id="per">10</span></div>
                </div>
                
                <!-- Status -->
                <div class="stat-group">
                    <h3>STATUS</h3>
                    <div>AC: <span id="ac">10</span> | Level: <span id="dungeon-level">1</span></div>
                    <div>Weight: <span id="current-weight">0</span>/<span id="max-weight">50</span> | Timer: <span id="timer">10</span>s</div>
                    <div>Sight: <span id="sight">5</span></div>
                    <div id="hunger-status"></div>
                    <div id="burden-status"></div>
                    <div id="status-effects"></div>
                </div>

                <!-- Equipment -->
                <div class="stat-group">
                    <h3>EQUIPMENT</h3>
                    <div id="equipment-list">
                        <div class="inventory-item">Nothing equipped</div>
                    </div>
                </div>

                <!-- Inventory -->
                <div class="stat-group">
                    <h3>INVENTORY</h3>
                    <div id="inventory-list">
                        <div class="inventory-item">Empty</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="controls">
                    <h4>CONTROLS</h4>
                    <div class="control-line">Press <span class="key">?</span> for commands</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal" class="modal">
        <div class="modal-content">
            <div class="quiz-header">
                <div class="quiz-title" id="quiz-title">Knowledge Challenge</div>
                <div id="quiz-subject">Mathematics</div>
                <div class="quiz-timer" id="quiz-timer">30</div>
                <div class="quiz-progress" id="quiz-progress">Question 1 | Score: 0</div>
            </div>
            <div class="quiz-question" id="quiz-question">Question will appear here</div>
            <div id="quiz-input-area">
                <input type="text" class="quiz-input" id="quiz-answer" placeholder="Type your answer..." autocomplete="off">
                <button class="quiz-button" id="quiz-submit">Submit Answer</button>
            </div>
            <div class="quiz-feedback" id="quiz-feedback" style="display: none;"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="quiz-header">
                <div class="quiz-title">COMMAND REFERENCE</div>
                <div style="color: var(--text-secondary); font-size: 14px;">Press ESC or ? to close</div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Movement</h3>
                    <div class="help-command"><span class="key">Arrows/Numpad</span> Move/Attack</div>
                    <div class="help-command"><span class="key">5 / . / Space</span> Wait</div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Dungeon</h3>
                    <div class="help-command"><span class="key">&gt;</span> Descend stairs</div>
                    <div class="help-command"><span class="key">&lt;</span> Ascend stairs <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Items</h3>
                    <div class="help-command"><span class="key">, / g</span> Get item</div>
                    <div class="help-command"><span class="key">d</span> Drop item <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">i</span> Inventory <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">e</span> Equip item <span style="color: var(--text-dim);">(not yet)</span></div>
                </div>
                
                <div>
                    <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Food System</h3>
                    <div class="help-command"><span class="key">h</span> Harvest corpse <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">c</span> Cook ingredients <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Magic</h3>
                    <div class="help-command"><span class="key">r</span> Read scroll/book <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">q</span> Quaff potion <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">z</span> Zap wand <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">C</span> Cast spell <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Special</h3>
                    <div class="help-command"><span class="key">I</span> Identify <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">p</span> Pray <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">l</span> Lockpick <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">f</span> Fire ranged <span style="color: var(--text-dim);">(not yet)</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Cooking Modal -->
    <div id="cooking-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="quiz-header">
                <div class="quiz-title">COOKING STATION</div>
                <div style="color: var(--text-secondary); font-size: 14px;">Choose ingredients to cook</div>
            </div>
            
            <div style="padding: 20px;">
                <h3 style="color: var(--gold-bright); margin-bottom: 15px;">Available Ingredients:</h3>
                <div id="ingredient-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- Ingredients will be populated here -->
                </div>
                
                <div style="margin-top: 20px; text-align: center;">
                    <button class="quiz-button" onclick="Game.cancelCooking()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Exit Confirmation Modal -->
    <div id="exit-modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="quiz-header">
                <div class="quiz-title">LEAVE THE DUNGEON?</div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p id="exit-message" style="font-size: 16px; margin-bottom: 20px;"></p>
                <div style="margin-top: 30px;">
                    <button class="quiz-button" onclick="Game.confirmExit()">Yes, Leave</button>
                    <button class="quiz-button" onclick="Game.cancelExit()">No, Stay</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victory-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="quiz-header">
                <div class="quiz-title" style="color: var(--gold-bright); font-size: 36px; text-shadow: 0 0 30px var(--glow-color);">
                    VICTORY!
                </div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="font-size: 20px; color: var(--wisdom-purple); margin: 20px 0;">
                    You have retrieved the Philosopher's Stone!
                </p>
                <p style="font-size: 16px; color: var(--text-primary); margin: 20px 0;">
                    Knowledge truly is power. You have proven yourself worthy<br>
                    by mastering both wisdom and courage to complete your quest.
                </p>
                <div style="font-size: 24px; color: var(--gold-bright); margin: 30px 0; animation: pulse 2s infinite;">
                    ✦ ✦ ✦
                </div>
                <button class="quiz-button" onclick="Game.showScoreboard()">View Your Legacy</button>
            </div>
        </div>
    </div>

    <!-- Scoreboard Modal -->
    <div id="scoreboard-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="quiz-header">
                <div class="quiz-title">FINAL SCORE</div>
                <div id="score-result" style="font-size: 18px; margin-top: 10px;"></div>
            </div>
            <div id="scoreboard-content" style="padding: 20px;">
                <!-- Score details will be inserted here -->
            </div>
            <div style="text-align: center; padding: 20px;">
                <button class="quiz-button" onclick="location.reload()">New Game</button>
            </div>
        </div>
    </div>
    <script>
        // ===== PHILOSOPHER'S QUEST - COMPLETE GAME =====
        
        // Global game state
        const Game = {
            // Core state
            player: null,
            dungeon: null,
            monsters: [],
            items: [],
            currentLevel: 1,
            turn: 0,
            
            // Display
            display: null,
            messageLog: [],
            maxMessages: 100,
            
            // Quiz state
            activeQuiz: null,
            quizTimer: null,
            quizTimeRemaining: 0,
            
            // Game configuration
            config: {
                mapWidth: 80,
                mapHeight: 25,
                baseHP: 20,
                baseSP: 100,
                baseMP: 10,
                startingWisdom: 10
            }
        };

        // ===== UNIFIED MENU SYSTEM =====
        Game.MenuSystem = {
            activeMenu: null,
            menuItems: [],
            selectedIndex: -1,
            
            show: function(title, items, callback, subtitle = '') {
                // Close any existing menu
                this.close();
                
                // Store menu data
                this.menuItems = items;
                this.callback = callback;
                this.activeMenu = true;
                
                // Create menu HTML
                const menuHTML = this.createMenuHTML(title, items, subtitle);
                
                // Add menu to page
                const menuContainer = document.createElement('div');
                menuContainer.id = 'universal-menu';
                menuContainer.className = 'universal-menu active';
                menuContainer.innerHTML = menuHTML;
                document.body.appendChild(menuContainer);
                
                // Add event listeners
                this.attachEventListeners();
                
                // Focus menu for keyboard input
                menuContainer.focus();
            },
            
            createMenuHTML: function(title, items, subtitle) {
                let html = `
                    <div class="menu-content">
                        <div class="menu-header">
                            <div class="menu-title">${title}</div>
                            ${subtitle ? `<div class="menu-subtitle">${subtitle}</div>` : ''}
                        </div>
                        <div class="menu-items">
                `;
                
                items.forEach((item, index) => {
                    const letter = String.fromCharCode(97 + index); // a, b, c, etc.
                    const disabled = item.disabled ? 'disabled' : '';
                    const disabledText = item.disabled ? ' (unavailable)' : '';
                    
                    html += `
                        <div class="menu-item ${disabled}" data-index="${index}" data-letter="${letter}">
                            <span class="menu-letter">${letter})</span>
                            <span class="menu-text">${item.name}${disabledText}</span>
                            ${item.description ? `<span class="menu-description">${item.description}</span>` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                        <div class="menu-footer">
                            Press letter to select, or ESC to cancel
                        </div>
                    </div>
                `;
                
                return html;
            },
            
            attachEventListeners: function() {
                const menu = document.getElementById('universal-menu');
                if (!menu) return;
                
                // Mouse hover
                const items = menu.querySelectorAll('.menu-item:not(.disabled)');
                items.forEach(item => {
                    item.addEventListener('mouseenter', () => {
                        this.selectItem(parseInt(item.dataset.index));
                    });
                    
                    item.addEventListener('click', () => {
                        this.confirmSelection();
                    });
                });
                
                // Keyboard handler
                this.keyHandler = (e) => this.handleKeyPress(e);
                document.addEventListener('keydown', this.keyHandler);
            },
            
            handleKeyPress: function(e) {
                if (!this.activeMenu) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // ESC to cancel
                if (e.key === 'Escape') {
                    this.close();
                    return;
                }
                
                // Letter selection (a-z)
                const letter = e.key.toLowerCase();
                const index = letter.charCodeAt(0) - 97;
                
                if (index >= 0 && index < this.menuItems.length) {
                    if (!this.menuItems[index].disabled) {
                        this.selectedIndex = index;
                        this.confirmSelection();
                    }
                    return;
                }
                
                // Arrow keys
                if (e.key === 'ArrowUp') {
                    this.moveSelection(-1);
                } else if (e.key === 'ArrowDown') {
                    this.moveSelection(1);
                } else if (e.key === 'Enter' && this.selectedIndex >= 0) {
                    this.confirmSelection();
                }
            },
            
            selectItem: function(index) {
                if (index < 0 || index >= this.menuItems.length) return;
                if (this.menuItems[index].disabled) return;
                
                // Remove old selection
                const items = document.querySelectorAll('.menu-item');
                items.forEach(item => item.classList.remove('selected'));
                
                // Add new selection
                this.selectedIndex = index;
                items[index].classList.add('selected');
            },
            
            moveSelection: function(direction) {
                let newIndex = this.selectedIndex + direction;
                
                // Wrap around
                if (newIndex < 0) newIndex = this.menuItems.length - 1;
                if (newIndex >= this.menuItems.length) newIndex = 0;
                
                // Skip disabled items
                while (this.menuItems[newIndex].disabled) {
                    newIndex += direction;
                    if (newIndex < 0) newIndex = this.menuItems.length - 1;
                    if (newIndex >= this.menuItems.length) newIndex = 0;
                }
                
                this.selectItem(newIndex);
            },
            
            confirmSelection: function() {
                if (this.selectedIndex < 0 || this.selectedIndex >= this.menuItems.length) return;
                
                const selected = this.menuItems[this.selectedIndex];
                if (selected.disabled) return;
                
                this.close();
                
                if (this.callback) {
                    this.callback(selected);
                }
            },
            
            close: function() {
                const menu = document.getElementById('universal-menu');
                if (menu) {
                    menu.remove();
                }
                
                if (this.keyHandler) {
                    document.removeEventListener('keydown', this.keyHandler);
                }
                
                this.activeMenu = null;
                this.menuItems = [];
                this.selectedIndex = -1;
                this.callback = null;
            }
        };

        // ===== DICE SYSTEM =====
        Game.Dice = {
            // Parse and roll dice notation: "2d6+3", "1d20", "3d4-2", etc.
            roll: function(notation) {
                if (!notation) return 0;
                
                // Handle plain numbers
                if (!isNaN(notation)) return parseInt(notation);
                
                // Parse dice notation with regex
                const match = notation.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
                if (!match) return parseInt(notation) || 0;
                
                const count = parseInt(match[1] || 1);
                const sides = parseInt(match[2]);
                const modifier = parseInt(match[3] || 0);
                
                let total = modifier;
                for (let i = 0; i < count; i++) {
                    total += Math.floor(Math.random() * sides) + 1;
                }
                
                return Math.max(0, total); // Never return negative
            },
            
            // Roll with advantage (roll twice, take higher)
            rollAdvantage: function(notation) {
                return Math.max(this.roll(notation), this.roll(notation));
            },
            
            // Roll with disadvantage (roll twice, take lower)
            rollDisadvantage: function(notation) {
                return Math.min(this.roll(notation), this.roll(notation));
            },
            
            // Roll multiple times and return array
            rollMultiple: function(notation, times) {
                const results = [];
                for (let i = 0; i < times; i++) {
                    results.push(this.roll(notation));
                }
                return results;
            },
            
            // Check if roll meets or exceeds target
            check: function(notation, target) {
                return this.roll(notation) >= target;
            },
            
            // Get average result for a dice notation (for balancing)
            average: function(notation) {
                const match = notation.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
                if (!match) return parseInt(notation) || 0;
                
                const count = parseInt(match[1] || 1);
                const sides = parseInt(match[2]);
                const modifier = parseInt(match[3] || 0);
                
                return (count * (sides + 1) / 2) + modifier;
            }
        };


        // ===== QUIZ ENGINE =====
        Game.QuizEngine = {
            currentQuiz: null,
            timer: null,
            timeRemaining: 0,
            isActive: false,
            questions: {},
            loaded: false,
            
            // Load all question banks at startup
            loadAllQuestions: async function() {
                if (this.loaded) return;
                
                const subjects = [
                    'math', 'philosophy', 'geography', 'science', 
                    'history', 'economics', 'cooking', 'grammar', 'animal'
                ];
                
                console.log('Loading question banks...');
                
                for (const subject of subjects) {
                    try {
                        const response = await fetch(`data/questions/questions-${subject}.json`);
                        if (!response.ok) {
                            console.warn(`✗ ${subject} questions not found, using placeholders`);
                            // Create obvious placeholder questions inline
                            this.questions[subject] = {
                                "1": [
                                    {"question": `PLACEHOLDER ${subject}: What is 1 × 1?`, "answer": "1", "type": "input"},
                                    {"question": `PLACEHOLDER ${subject}: What is 1 × 1?`, "answer": "1", "type": "input"}
                                ]
                            };
                        } else {
                            const data = await response.json();
                            // Handle the nested structure - data.subject contains the tiers
                            if (data[subject]) {
                                this.questions[subject] = data[subject];
                            } else {
                                // Fallback if structure is different
                                this.questions[subject] = data;
                            }
                            console.log(`✓ Loaded ${subject}`);
                        }
                    } catch (error) {
                        console.error(`Failed to load ${subject}:`, error);
                        // Create obvious placeholder questions inline
                        this.questions[subject] = {
                            "1": [
                                {"question": `PLACEHOLDER ${subject}: What is 1 × 1?`, "answer": "1", "type": "input"},
                                {"question": `PLACEHOLDER ${subject}: What is 1 × 1?`, "answer": "1", "type": "input"}
                            ]
                        };
                    }
                }
                
                this.loaded = true;
                console.log('Question loading complete!');
            },
            
            // Get a random question from subject and tier
            getRandomQuestion: function(subject, tier = 1) {
                const tierKey = tier.toString();
                
                if (!this.questions[subject]) {
                    console.error(`Subject ${subject} not loaded`);
                    return null;
                }
                
                if (!this.questions[subject][tierKey]) {
                    // Fallback to tier 1
                    if (this.questions[subject]["1"]) {
                        // Handle both array format and object format
                        const tierData = this.questions[subject]["1"];
                        const questions = Array.isArray(tierData) ? tierData : tierData.questions;
                        return questions[Math.floor(Math.random() * questions.length)];
                    }
                    return null;
                }
                
                // Handle both array format and object format
                const tierData = this.questions[subject][tierKey];
                const questions = Array.isArray(tierData) ? tierData : tierData.questions;
                return questions[Math.floor(Math.random() * questions.length)];
            },
            
            // Start a quiz with specified parameters
            startQuiz: function(params) {
                if (this.isActive) {
                    console.warn('Quiz already active');
                    return;
                }
                
                // Initialize quiz state
                this.currentQuiz = {
                    mode: params.mode,
                    subject: params.subject,
                    currentTier: params.startingTier || 1,
                    threshold: params.threshold || 0,
                    maxChain: params.maxChain || 0,
                    callback: params.callback,
                    reason: params.reason || 'quiz',
                    target: params.target || null,
                    
                    // Progress tracking
                    correctCount: 0,
                    totalAsked: 0,
                    currentQuestion: null,
                    questionHistory: []
                };
                
                this.isActive = true;
                
                // Show quiz start message
                const subjectName = params.subject.charAt(0).toUpperCase() + params.subject.slice(1);
                Game.addMessage(`${subjectName} challenge begins! (${this.getModeDescription(params.mode)})`, 'info');
                
                // Show first question
                this.showNextQuestion();
            },
            
            // Show the next question
            showNextQuestion: function() {
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                // Check if quiz should end
                if (this.shouldEndQuiz()) {
                    this.endQuiz(true);
                    return;
                }
                
                // Get next question
                const question = this.getRandomQuestion(quiz.subject, quiz.currentTier);
                if (!question) {
                    console.error(`No questions available for ${quiz.subject} tier ${quiz.currentTier}`);
                    this.endQuiz(false);
                    return;
                }
                
                quiz.currentQuestion = question;
                quiz.totalAsked++;
                
                // Calculate timer based on wisdom
                // Only set timer and start it on the FIRST question
                if (quiz.correctCount === 0 && quiz.totalAsked === 1) {
                    this.timeRemaining = Game.player.getQuizTimer();
                    this.startTimer();
                }

                // Show quiz modal
                this.showQuizModal(question);
            },
            
            // Check if quiz should end
            shouldEndQuiz: function() {
                const quiz = this.currentQuiz;
                
                switch (quiz.mode) {
                    case 'threshold':
                    case 'escalator_threshold':
                        return quiz.correctCount >= quiz.threshold;
                    case 'chain':
                    case 'escalator_chain':
                        // Chain ends on first wrong answer, checked elsewhere
                        return quiz.correctCount >= quiz.maxChain;
                    default:
                        return false;
                }
            },

            // Display the quiz modal
            showQuizModal: function(question) {
                const modal = document.getElementById('quiz-modal');
                const quiz = this.currentQuiz;
                
                // Update modal content
                document.getElementById('quiz-title').textContent = quiz.reason || 'Knowledge Challenge';
                document.getElementById('quiz-subject').textContent = quiz.subject.toUpperCase();
                document.getElementById('quiz-question').textContent = question.question;
                document.getElementById('quiz-timer').textContent = this.timeRemaining;
                document.getElementById('quiz-progress').textContent = 
                    `Question ${quiz.totalAsked} | Score: ${quiz.correctCount}`;
                
                // Clear previous answer area
                const inputArea = document.getElementById('quiz-input-area');
                inputArea.innerHTML = '';
                
                // Check question type
                if (question.type === 'multiple' && question.options) {
                    // Multiple choice question
                    // Shuffle options
                    const shuffled = [...question.options].sort(() => Math.random() - 0.5);
                    
                    // Create button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;';
                    
                    // Create buttons for each option
                    shuffled.forEach((option, index) => {
                        const button = document.createElement('button');
                        button.className = 'quiz-choice-button';
                        button.innerHTML = `
                            <span class="choice-letter">${String.fromCharCode(65 + index)}</span>
                            <span class="choice-text">${option}</span>
                        `;
                        button.dataset.answer = option;
                        button.onclick = () => this.selectChoice(option);
                        
                        // Add keyboard shortcut
                        button.dataset.key = String.fromCharCode(65 + index);
                        
                        buttonContainer.appendChild(button);
                    });
                    
                    inputArea.appendChild(buttonContainer);
                    
                    // Store selected answer
                    this.selectedChoice = null;
                    
                } else {
                    // Input question (default)
                    inputArea.innerHTML = `
                        <input type="text" class="quiz-input" id="quiz-answer" 
                               placeholder="Type your answer..." autocomplete="off">
                        <button class="quiz-button" id="quiz-submit">Submit Answer</button>
                    `;
                    
                    // Re-attach event listener for input
                    setTimeout(() => {
                        const input = document.getElementById('quiz-answer');
                        if (input) {
                            input.focus();
                            input.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    const answer = e.target.value;
                                    if (answer && Game.QuizEngine.isActive) {
                                        Game.QuizEngine.handleAnswer(answer);
                                    }
                                }
                            });
                        }
                        
                        const submitBtn = document.getElementById('quiz-submit');
                        if (submitBtn) {
                            submitBtn.onclick = () => {
                                const answer = document.getElementById('quiz-answer').value;
                                if (answer && Game.QuizEngine.isActive) {
                                    Game.QuizEngine.handleAnswer(answer);
                                }
                            };
                        }
                    }, 100);
                }
                
                // Clear feedback
                document.getElementById('quiz-feedback').style.display = 'none';
                
                // Show modal
                modal.classList.add('active');
            },
            
            // Select a multiple choice option
            selectChoice: function(answer) {
                this.selectedChoice = answer;
                
                // Update button styles
                document.querySelectorAll('.quiz-choice-button').forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.dataset.answer === answer) {
                        btn.classList.add('selected');
                    }
                });
                
                // Auto-submit after a brief delay for visual feedback
                setTimeout(() => this.submitMultipleChoice(), 200);
            },
            
            // Submit multiple choice answer
            submitMultipleChoice: function() {
                if (this.selectedChoice && this.isActive) {
                    this.handleAnswer(this.selectedChoice);
                }
            },
            
            // Handle answer submission
            handleAnswer: function(answer) {
                const quiz = this.currentQuiz;
                if (!quiz || !quiz.currentQuestion) return;
                
                // Normalize answers
                const normalizedAnswer = answer.toLowerCase().trim().replace(/[.,!?;]/g, '');
                const normalizedCorrect = (quiz.currentQuestion.answer || '').toLowerCase().trim().replace(/[.,!?;]/g, '');
                
                const correct = normalizedAnswer === normalizedCorrect;
                
                if (correct) {
                    quiz.correctCount++;
                    quiz.questionHistory.push({question: quiz.currentQuestion, correct: true});
                    
                    Game.addMessage('Correct!', 'success');
                    const answerInput = document.getElementById('quiz-answer');
                    if (answerInput) answerInput.value = '';
                    
                    // Check if we should continue or end
                    if (quiz.mode === 'threshold' || quiz.mode === 'escalator_threshold') {
                        // Threshold: check if we've reached the required number
                        if (quiz.correctCount >= quiz.threshold) {
                            this.endQuiz(true);  // Success!
                        } else {
                            // Need more correct answers
                            if (quiz.mode === 'escalator_threshold' && quiz.currentTier < 5) {
                                quiz.currentTier++;
                            }
                            this.showNextQuestion();
                        }
                    } else if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                        // Chain: check if we've hit max chain
                        if (quiz.maxChain && quiz.correctCount >= quiz.maxChain) {
                            this.endQuiz(true);  // Max chain reached
                        } else {
                            // Continue chain
                            if (quiz.mode === 'escalator_chain' && quiz.currentTier < 5) {
                                quiz.currentTier++;
                            }
                            this.showNextQuestion();
                        }
                    }
                    
                } else {
                    // Wrong answer - quiz ALWAYS ends
                    quiz.questionHistory.push({
                        question: quiz.currentQuestion, 
                        correct: false,
                        userAnswer: answer
                    });
                    
                    Game.addMessage(`Wrong! The answer was: ${quiz.currentQuestion.answer}`, 'warning');
                    
                    // End quiz with current score
                    this.endQuiz(false);
                }
            },
            
            // End the quiz
            endQuiz: function(reachedGoal) {
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                this.stopTimer();
                
                // Build result
                const result = {
                    mode: quiz.mode,
                    subject: quiz.subject,
                    score: quiz.correctCount,
                    totalAsked: quiz.totalAsked,
                    success: false,
                    target: quiz.target
                };
                
                // Determine success based on mode
                if (quiz.mode === 'threshold' || quiz.mode === 'escalator_threshold') {
                    // Threshold modes: binary success only if reached threshold
                    result.success = quiz.correctCount >= quiz.threshold;
                } else if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                    // Chain modes: always "succeed" with the score you got
                    // Score 0 = complete failure, 1+ = incremental success
                    result.success = true;  // The callback will handle score-based outcomes
                }
                
                // Clear quiz state
                this.currentQuiz = null;
                this.isActive = false;
                
                // Hide modal
                document.getElementById('quiz-modal').classList.remove('active');
                
                // Call callback with result
                if (quiz.callback) {
                    quiz.callback(result);
                }
                
                // Show final message
                if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                    Game.addMessage(`Quiz ended. Chain length: ${result.score}`, 'info');
                } else {
                    if (result.success) {
                        Game.addMessage(`Quiz passed! Got ${result.score} correct.`, 'success');
                    } else {
                        Game.addMessage(`Quiz failed. Got ${result.score} correct, needed ${quiz.threshold}.`, 'warning');
                    }
                }
            },
            
            // Timer functions
            startTimer: function() {
                this.stopTimer();
                
                this.timer = setInterval(() => {
                    this.timeRemaining--;
                    
                    const timerEl = document.getElementById('quiz-timer');
                    timerEl.textContent = this.timeRemaining;
                    
                    // Add warning colors
                    if (this.timeRemaining <= 5) {
                        timerEl.className = 'quiz-timer danger';
                    } else if (this.timeRemaining <= 10) {
                        timerEl.className = 'quiz-timer warning';
                    }
                    
                    if (this.timeRemaining <= 0) {
                        this.handleTimeout();
                    }
                }, 1000);
            },
            
            stopTimer: function() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            },
            
            handleTimeout: function() {
                this.stopTimer();
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                Game.addMessage("Time's up!", 'danger');
                
                quiz.questionHistory.push({
                    question: quiz.currentQuestion,
                    correct: false,
                    timeout: true
                });
                
                // Show correct answer
                const feedback = document.getElementById('quiz-feedback');
                feedback.textContent = `Time's up! The answer was: ${quiz.currentQuestion.answer}`;
                feedback.className = 'quiz-feedback wrong';
                feedback.style.display = 'block';
                
                setTimeout(() => this.endQuiz(false), 2000);
            },
            
            getModeDescription: function(mode) {
                switch (mode) {
                    case 'threshold': return 'Answer correctly to succeed';
                    case 'chain': return 'Build a chain of correct answers';
                    case 'escalator_threshold': return 'Questions get harder';
                    case 'escalator_chain': return 'Chain with increasing difficulty';
                    default: return 'Quiz';
                }
            }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor(name = "Hero") {
                this.name = name;
                
                // Core attributes
                this.strength = 10;
                this.constitution = 10;
                this.dexterity = 10;
                this.intelligence = 10;
                this.wisdom = 10;
                this.perception = 10;
                
                // Derived stats
                this.maxHp = Game.config.baseHP + Math.floor((this.constitution - 10) / 2);
                this.hp = this.maxHp;
                this.maxSp = Game.config.baseSP + (this.constitution - 10) * 2;
                this.sp = this.maxSp;
                this.maxMp = Game.config.baseMP + Math.floor((this.intelligence - 10) / 2);
                this.mp = this.maxMp;
                
                // Position
                this.x = 0;
                this.y = 0;
                
                // Equipment slots
                this.equipped = {
                    weapon: null,        // Primary weapon (no quiz needed)
                    shield: null,        // Off-hand (can't use with 2H weapons)
                    armor: {
                        head: null,      // Helmet
                        body: null,      // Chest armor  
                        arms: null,      // Arm guards/bracers
                        hands: null,     // Gloves
                        legs: null,      // Leg armor
                        feet: null,      // Boots
                        cloak: null,     // Outer cloak/cape
                        shirt: null      // Under-armor
                    },
                    accessories: {
                        leftRing: null,
                        rightRing: null,
                        amulet: null,    // Neck slot
                        belt: null       // Optional utility belt
                    }
                };
                
                // Inventory
                this.inventory = [];
                this.maxCarry = 50 + this.strength * 2;
                this.currentWeight = 0;
                
                // Status flags
                this.statusFlags = {
                    isStarving: false,
                    isConfused: false,
                    isBlind: false,
                    isStunned: false,
                    isHallucinating: false,
                    isParalyzed: false,
                    isSick: false,
                    isPoisoned: false,
                    isStoned: false,
                    isSlimed: false,
                    isLevitating: false,
                    isFlying: false,
                    isInvisible: false
                };
                
                // Status effect durations and intensities
                this.statusEffects = {
                    poison: { duration: 0, damage: 0 },
                    disease: { duration: 0, severity: 0 },
                    paralysis: { duration: 0 },
                    stun: { duration: 0 },
                    confusion: { duration: 0 },
                    blindness: { duration: 0 },
                    burning: { duration: 0, damage: 0 },
                    freezing: { duration: 0, slow: 0 },
                    shock: { duration: 0, spasms: false }
                };
                
                // Resistances (0 = none, 1 = partial, 2 = full immunity)
                this.resistances = {
                    fire: 0,
                    cold: 0,
                    shock: 0,
                    poison: 0,
                    disease: 0,
                    paralysis: 0,
                    confusion: 0,
                    sleep: 0,
                    acid: 0
                };
                
                // Inventory letter assignment
                this.nextInventoryLetter = 'a';
            }
            
            getAC() {
                let ac = 10 + Math.floor((this.dexterity - 10) / 2);
                
                // Add armor bonuses
                Object.values(this.equipped.armor).forEach(armor => {
                    if (armor) ac += armor.ac_bonus || 0;
                });
                
                // Add shield bonus
                if (this.equipped.shield) {
                    ac += this.equipped.shield.ac_bonus || 0;
                }
                
                // Add accessory bonuses
                Object.values(this.equipped.accessories).forEach(accessory => {
                    if (accessory && accessory.ac_bonus) {
                        ac += accessory.ac_bonus;
                    }
                });
                
                return ac;
            }
            
            getSightRadius() {
                return 3 + Math.floor(this.perception / 5);
            }
            
            getQuizTimer() {
                return 20 + this.wisdom;
            }

            getHungerStatus() {
                const percent = this.sp / this.maxSp;
                if (this.sp <= 0) return "Starving";
                if (percent <= 0.1) return "Fainting";
                if (percent <= 0.2) return "Weak";
                if (percent <= 0.3) return "Hungry";
                if (percent >= 1.2) return "Satiated";
                return "";
            }
            
            getBurdenStatus() {
                const percent = (this.currentWeight / this.maxCarry) * 100;
                if (percent > 300) return "Overloaded";
                if (percent > 200) return "Overtaxed";
                if (percent > 150) return "Strained";
                if (percent > 100) return "Stressed";
                if (percent > 75) return "Burdened";
                return "";
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    Game.gameOver("You have died!");
                }
            }
            
            spendSP(amount = 1) {
                this.sp -= amount;
                if (this.sp <= 0) {
                    this.sp = 0;
                    this.statusFlags.isStarving = true;
                    this.takeDamage(1);
                    Game.addMessage("You're starving! You take damage!", 'danger');
                } else {
                    this.statusFlags.isStarving = false;
                }
            }
            
            restoreSP(amount) {
                this.sp = Math.min(this.maxSp, this.sp + amount);
                if (this.sp > 0) this.statusFlags.isStarving = false;
            }
            
            addToInventory(item) {
                if (this.currentWeight + (item.weight || 1) > this.maxCarry) {
                    Game.addMessage("You can't carry that much weight!", 'warning');
                    return false;
                }
                
                // Check if item is stackable and we already have some
                if (item.stackable) {
                    const existing = this.inventory.find(i => 
                        i.id === item.id && 
                        i.blessed === item.blessed && 
                        i.cursed === item.cursed
                    );
                    
                    if (existing) {
                        existing.quantity = (existing.quantity || 1) + (item.quantity || 1);
                        return true;
                    }
                }
                
                // Assign inventory letter
                item.letter = this.nextInventoryLetter;
                this.nextInventoryLetter = String.fromCharCode(this.nextInventoryLetter.charCodeAt(0) + 1);
                if (this.nextInventoryLetter > 'z') this.nextInventoryLetter = 'A';
                
                this.inventory.push(item);
                this.currentWeight += item.weight || 1;
                return true;
            }
            
            removeFromInventory(item) {
                const index = this.inventory.indexOf(item);
                if (index > -1) {
                    this.inventory.splice(index, 1);
                    this.currentWeight -= item.weight || 1;
                    return true;
                }
                return false;
            }

            processStatusEffects() {
                // Process poison
                if (this.statusEffects.poison.duration > 0) {
                    this.statusEffects.poison.duration--;
                    if (this.resistances.poison < 2) {
                        const poisonDamage = Math.max(1, Math.floor(this.statusEffects.poison.damage * (1 - this.resistances.poison * 0.5)));
                        this.takeDamage(poisonDamage);
                        Game.addMessage(`The poison courses through your veins! (-${poisonDamage} HP)`, 'danger');
                    }
                    if (this.statusEffects.poison.duration <= 0) {
                        this.statusFlags.isPoisoned = false;
                        Game.addMessage("You feel the poison leaving your system.", 'success');
                    }
                }
                
                // Process disease  
                if (this.statusEffects.disease.duration > 0) {
                    this.statusEffects.disease.duration--;
                    if (this.resistances.disease < 2) {
                        // Disease weakens stats temporarily
                        if (Game.turn % 10 === 0) {
                            Game.addMessage("You feel ill and weakened.", 'warning');
                        }
                    }
                    if (this.statusEffects.disease.duration <= 0) {
                        this.statusFlags.isSick = false;
                        Game.addMessage("You feel healthy again.", 'success');
                    }
                }
                
                // Process paralysis
                if (this.statusEffects.paralysis.duration > 0) {
                    this.statusEffects.paralysis.duration--;
                    if (this.statusEffects.paralysis.duration <= 0) {
                        this.statusFlags.isParalyzed = false;
                        Game.addMessage("You can move again!", 'success');
                    }
                }
                
                // Process stun
                if (this.statusEffects.stun.duration > 0) {
                    this.statusEffects.stun.duration--;
                    if (this.statusEffects.stun.duration <= 0) {
                        this.statusFlags.isStunned = false;
                        Game.addMessage("You feel steady again.", 'success');
                    }
                }
                
                // Process confusion
                if (this.statusEffects.confusion.duration > 0) {
                    this.statusEffects.confusion.duration--;
                    if (this.statusEffects.confusion.duration <= 0) {
                        this.statusFlags.isConfused = false;
                        Game.addMessage("Your mind clears.", 'success');
                    }
                }
                
                // Process blindness
                if (this.statusEffects.blindness.duration > 0) {
                    this.statusEffects.blindness.duration--;
                    if (this.statusEffects.blindness.duration <= 0) {
                        this.statusFlags.isBlind = false;
                        Game.addMessage("You can see again!", 'success');
                    }
                }
                
                // Process burning
                if (this.statusEffects.burning.duration > 0) {
                    this.statusEffects.burning.duration--;
                    if (this.resistances.fire < 2) {
                        const fireDamage = Math.max(1, Math.floor(this.statusEffects.burning.damage * (1 - this.resistances.fire * 0.5)));
                        this.takeDamage(fireDamage);
                        Game.addMessage(`You are burning! (-${fireDamage} HP)`, 'danger');
                    }
                }
                
                // Process freezing
                if (this.statusEffects.freezing.duration > 0) {
                    this.statusEffects.freezing.duration--;
                    if (this.statusEffects.freezing.duration <= 0) {
                        Game.addMessage("You warm up.", 'info');
                    }
                }
                
                // Process shock
                if (this.statusEffects.shock.duration > 0) {
                    this.statusEffects.shock.duration--;
                    if (this.statusEffects.shock.spasms && Math.random() < 0.3) {
                        Game.addMessage("Your muscles spasm from the electricity!", 'warning');
                    }
                }
            }
            
            applyStatusEffect(effect, duration, intensity = 1) {
                switch(effect) {
                    case 'poison':
                        if (this.resistances.poison >= 2) {
                            Game.addMessage("You resist the poison completely!", 'success');
                            return;
                        }
                        this.statusEffects.poison.duration = Math.max(this.statusEffects.poison.duration, duration);
                        this.statusEffects.poison.damage = Math.max(this.statusEffects.poison.damage, intensity);
                        this.statusFlags.isPoisoned = true;
                        Game.addMessage("You feel very sick!", 'danger');
                        break;
                        
                    case 'disease':
                        if (this.resistances.disease >= 2) {
                            Game.addMessage("Your constitution resists the disease!", 'success');
                            return;
                        }
                        this.statusEffects.disease.duration = Math.max(this.statusEffects.disease.duration, duration);
                        this.statusEffects.disease.severity = Math.max(this.statusEffects.disease.severity, intensity);
                        this.statusFlags.isSick = true;
                        Game.addMessage("You feel ill!", 'warning');
                        break;
                        
                    case 'paralysis':
                        if (this.resistances.paralysis >= 2) {
                            Game.addMessage("You resist the paralysis!", 'success');
                            return;
                        }
                        this.statusEffects.paralysis.duration = Math.max(this.statusEffects.paralysis.duration, duration);
                        this.statusFlags.isParalyzed = true;
                        Game.addMessage("You are paralyzed!", 'danger');
                        break;
                        
                    case 'stun':
                        this.statusEffects.stun.duration = Math.max(this.statusEffects.stun.duration, duration);
                        this.statusFlags.isStunned = true;
                        Game.addMessage("You feel stunned!", 'warning');
                        break;
                        
                    case 'confusion':
                        if (this.resistances.confusion >= 2) {
                            Game.addMessage("Your mind resists the confusion!", 'success');
                            return;
                        }
                        this.statusEffects.confusion.duration = Math.max(this.statusEffects.confusion.duration, duration);
                        this.statusFlags.isConfused = true;
                        Game.addMessage("You feel confused!", 'warning');
                        break;
                        
                    case 'blindness':
                        this.statusEffects.blindness.duration = Math.max(this.statusEffects.blindness.duration, duration);
                        this.statusFlags.isBlind = true;
                        Game.addMessage("You can't see!", 'danger');
                        break;
                        
                    case 'burning':
                        if (this.resistances.fire >= 2) {
                            Game.addMessage("You resist the flames!", 'success');
                            return;
                        }
                        this.statusEffects.burning.duration = Math.max(this.statusEffects.burning.duration, duration);
                        this.statusEffects.burning.damage = Math.max(this.statusEffects.burning.damage, intensity);
                        Game.addMessage("You are on fire!", 'danger');
                        break;
                        
                    case 'freezing':
                        if (this.resistances.cold >= 2) {
                            Game.addMessage("You resist the cold!", 'success');
                            return;
                        }
                        this.statusEffects.freezing.duration = Math.max(this.statusEffects.freezing.duration, duration);
                        this.statusEffects.freezing.slow = intensity;
                        Game.addMessage("You are freezing!", 'warning');
                        break;
                        
                    case 'shock':
                        if (this.resistances.shock >= 2) {
                            Game.addMessage("You resist the electricity!", 'success');
                            return;
                        }
                        this.statusEffects.shock.duration = Math.max(this.statusEffects.shock.duration, duration);
                        this.statusEffects.shock.spasms = true;
                        Game.addMessage("Electricity courses through you!", 'warning');
                        break;
                }
            }
        }
        
        // ===== EQUIPMENT MANAGEMENT =====
        Game.equipItem = function(item) {
            if (!item) {
                Game.addMessage("What do you want to equip?", 'info');
                Game.showEquipmentMenu();
                return;
            }
            
            // Determine slot and quiz requirements
            let slot = null;
            let quizSubject = null;
            let quizThreshold = 3;
            
            // Weapons - no quiz required
            if (item.itemClass === 'weapons') {
                // Check if two-handed weapon conflicts with shield
                if (item.two_handed && Game.player.equipped.shield) {
                    Game.addMessage("You must unequip your shield first to wield a two-handed weapon!", 'warning');
                    return;
                }
                
                // Unequip current weapon if any
                if (Game.player.equipped.weapon) {
                    Game.unequipItem(Game.player.equipped.weapon, true);
                }
                
                Game.player.equipped.weapon = item;
                Game.player.removeFromInventory(item);
                Game.addMessage(`You wield the ${item.name}.`, 'success');
                Game.processTurn();
                return;
            }
            
            // Shields - Geography quiz
            if (item.itemClass === 'shields') {
                // Check for two-handed weapon conflict
                if (Game.player.equipped.weapon && Game.player.equipped.weapon.two_handed) {
                    Game.addMessage("You can't use a shield with a two-handed weapon!", 'warning');
                    return;
                }
                
                slot = 'shield';
                quizSubject = 'geography';
                quizThreshold = item.equip_threshold || 2;
            }
            // Armor - Geography quiz
            else if (item.itemClass === 'armor') {
                // Determine which armor slot
                const armorSlot = item.slot || 'body'; // Default to body if not specified
                
                if (!Game.player.equipped.armor.hasOwnProperty(armorSlot)) {
                    Game.addMessage(`Invalid armor slot: ${armorSlot}`, 'danger');
                    return;
                }
                
                slot = `armor.${armorSlot}`;
                quizSubject = 'geography';
                quizThreshold = item.equip_threshold || 3;
            }
            // Accessories - History quiz
            else if (item.itemClass === 'accessories') {
                if (item.slot === 'ring') {
                    // Choose which ring finger
                    if (!Game.player.equipped.accessories.leftRing) {
                        slot = 'accessories.leftRing';
                    } else if (!Game.player.equipped.accessories.rightRing) {
                        slot = 'accessories.rightRing';
                    } else {
                        Game.addMessage("Both ring fingers are occupied! Unequip a ring first.", 'warning');
                        return;
                    }
                } else if (item.slot === 'amulet') {
                    slot = 'accessories.amulet';
                } else if (item.slot === 'belt') {
                    slot = 'accessories.belt';
                } else {
                    Game.addMessage(`Unknown accessory type: ${item.slot}`, 'warning');
                    return;
                }
                
                quizSubject = 'history';
                quizThreshold = item.equip_threshold || 3;
            } else {
                Game.addMessage(`You can't equip ${item.name}!`, 'warning');
                return;
            }
            
            // Check if slot is occupied
            const currentItem = Game.getEquippedItem(slot);
            if (currentItem && currentItem.cursed) {
                Game.addMessage(`The ${currentItem.name} is cursed and won't come off!`, 'danger');
                return;
            }
            
            // Store the item and slot for after the quiz
            Game.pendingEquip = {
                item: item,
                slot: slot,
                currentItem: currentItem
            };
            
            // Start the quiz
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: quizSubject,
                startingTier: item.quiz_tier || 1,
                threshold: quizThreshold,
                reason: `Equipping ${item.name}`,
                target: item,
                callback: function(result) {
                    Game.handleEquipResult(result);
                }
            });
        };
        
        Game.handleEquipResult = function(result) {
            const pending = Game.pendingEquip;
            if (!pending) return;
            
            if (result.success) {
                // Unequip current item if any
                if (pending.currentItem) {
                    Game.unequipItem(pending.currentItem, true);
                }
                
                // Equip the new item
                Game.setEquippedItem(pending.slot, pending.item);
                pending.item.equipped = true;
                Game.player.removeFromInventory(pending.item);
                Game.addMessage(`You equip the ${pending.item.name}.`, 'success');
                
                // Apply any special effects
                if (pending.item.onEquip) {
                    pending.item.onEquip(Game.player);
                }
            } else {
                Game.addMessage(`You fail to properly equip the ${pending.item.name}.`, 'warning');
            }
            
            Game.pendingEquip = null;
            Game.processTurn();
        };
        
        Game.unequipItem = function(item, silent = false) {
            if (!item) {
                Game.addMessage("What do you want to unequip?", 'info');
                Game.showUnequipMenu();
                return;
            }
            
            if (item.cursed) {
                if (!silent) {
                    Game.addMessage(`The ${item.name} is cursed and won't come off!`, 'danger');
                }
                return false;
            }
            
            // Find where item is equipped
            let unequipped = false;
            
            // Check weapon
            if (Game.player.equipped.weapon === item) {
                Game.player.equipped.weapon = null;
                unequipped = true;
            }
            
            // Check shield
            if (Game.player.equipped.shield === item) {
                Game.player.equipped.shield = null;
                unequipped = true;
            }
            
            // Check armor slots
            for (let slot in Game.player.equipped.armor) {
                if (Game.player.equipped.armor[slot] === item) {
                    Game.player.equipped.armor[slot] = null;
                    unequipped = true;
                    break;
                }
            }
            
            // Check accessories
            for (let slot in Game.player.equipped.accessories) {
                if (Game.player.equipped.accessories[slot] === item) {
                    Game.player.equipped.accessories[slot] = null;
                    unequipped = true;
                    break;
                }
            }
            
            if (unequipped) {
                item.equipped = false;
                // Apply any removal effects
                if (item.onUnequip) {
                    item.onUnequip(Game.player);
                }
                
                // Add back to inventory
                if (Game.player.addToInventory(item)) {
                    if (!silent) {
                        Game.addMessage(`You unequip the ${item.name}.`, 'info');
                    }
                } else {
                    // Drop if can't carry
                    item.x = Game.player.x;
                    item.y = Game.player.y;
                    Game.items.push(item);
                    if (!silent) {
                        Game.addMessage(`You unequip and drop the ${item.name} (too heavy to carry).`, 'warning');
                    }
                }
                
                if (!silent) {
                    Game.processTurn();
                }
                return true;
            }
            
            if (!silent) {
                Game.addMessage(`You're not wearing the ${item.name}!`, 'warning');
            }
            return false;
        };
        
        // Helper functions for equipment
        Game.getEquippedItem = function(slotPath) {
            const parts = slotPath.split('.');
            let current = Game.player.equipped;
            
            for (let part of parts) {
                current = current[part];
                if (current === undefined) return null;
            }
            
            return current;
        };
        
        Game.setEquippedItem = function(slotPath, item) {
            const parts = slotPath.split('.');
            let current = Game.player.equipped;
            
            for (let i = 0; i < parts.length - 1; i++) {
                current = current[parts[i]];
            }
            
            current[parts[parts.length - 1]] = item;
        };

        // Equipment menu functions
        Game.promptEquip = function() {
            const equipable = Game.player.inventory.filter(item => 
                item.itemClass === 'weapons' || 
                item.itemClass === 'armor' || 
                item.itemClass === 'shields' ||
                item.itemClass === 'accessories'
            );
            
            if (equipable.length === 0) {
                Game.addMessage("You have nothing to equip!", 'info');
                return;
            }
            
            // Build menu items
            const menuItems = equipable.map(item => {
                let description = '';
                if (item.ac_bonus) description = `AC +${item.ac_bonus}`;
                if (item.base_damage) description = `Damage: ${item.base_damage}`;
                if (item.cursed) description += ' (cursed)';
                
                return {
                    name: item.name,
                    description: description,
                    data: item
                };
            });
            
            Game.MenuSystem.show(
                'EQUIP ITEM',
                menuItems,
                (selected) => {
                    Game.equipItem(selected.data);
                },
                'Choose an item to equip'
            );
        };
        
        Game.promptUnequip = function() {
            const equipped = Game.getAllEquippedItems();
            
            if (equipped.length === 0) {
                Game.addMessage("You have nothing equipped!", 'info');
                return;
            }
            
            // Build menu items  
            const menuItems = equipped.map(item => ({
                name: item.name,
                description: item.cursed ? 'Cannot remove - cursed!' : '',
                disabled: item.cursed,
                data: item
            }));
            
            Game.MenuSystem.show(
                'UNEQUIP ITEM',
                menuItems,
                (selected) => {
                    Game.unequipItem(selected.data);
                },
                'Choose an item to remove'
            );
        };
        
        Game.getAllEquippedItems = function() {
            const items = [];
            
            if (Game.player.equipped.weapon) items.push(Game.player.equipped.weapon);
            if (Game.player.equipped.shield) items.push(Game.player.equipped.shield);
            
            for (let slot in Game.player.equipped.armor) {
                if (Game.player.equipped.armor[slot]) {
                    items.push(Game.player.equipped.armor[slot]);
                }
            }
            
            for (let slot in Game.player.equipped.accessories) {
                if (Game.player.equipped.accessories[slot]) {
                    items.push(Game.player.equipped.accessories[slot]);
                }
            }
            
            return items;
        };

        // ===== FOV (FIELD OF VIEW) =====
        // Shadowcasting algorithm for proper line of sight
        Game.calculateFOV = function() {
            // If blind, can only see adjacent squares
            if (Game.player.statusFlags.isBlind) {
                const fov = [];
                for (let y = 0; y < Game.config.mapHeight; y++) {
                    fov[y] = [];
                    for (let x = 0; x < Game.config.mapWidth; x++) {
                        fov[y][x] = false;
                    }
                }
                
                // Only see immediately adjacent squares
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const x = Game.player.x + dx;
                        const y = Game.player.y + dy;
                        if (y >= 0 && y < fov.length && x >= 0 && x < fov[0].length) {
                            fov[y][x] = true;
                        }
                    }
                }
                return fov;
            }

            const fov = [];
            for (let y = 0; y < Game.config.mapHeight; y++) {
                fov[y] = [];
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    fov[y][x] = false;
                }
            }
            
            const px = Game.player.x;
            const py = Game.player.y;
            const radius = Game.player.getSightRadius();
            
            // Player can always see themselves
            if (py >= 0 && py < fov.length && px >= 0 && px < fov[0].length) {
                fov[py][px] = true;
            }
            
            // Cast light in 8 octants
            for (let octant = 0; octant < 8; octant++) {
                Game.castLight(fov, px, py, radius, 1, 1.0, 0.0, 
                    Game.multipliers[0][octant], Game.multipliers[1][octant],
                    Game.multipliers[2][octant], Game.multipliers[3][octant]);
            }
            
            return fov;
        };
        
        // Shadowcasting octant multipliers
        Game.multipliers = [
            [1, 0, 0, -1, -1, 0, 0, 1],
            [0, 1, -1, 0, 0, -1, 1, 0],
            [0, 1, 1, 0, 0, -1, -1, 0],
            [1, 0, 0, 1, -1, 0, 0, -1]
        ];
        
        Game.castLight = function(fov, cx, cy, radius, row, start, end, xx, xy, yx, yy) {
            if (start < end) return;
            
            const radius2 = radius * radius;
            
            for (let j = row; j <= radius; j++) {
                let dx = -j - 1;
                let dy = -j;
                let blocked = false;
                let newStart = start;
                
                while (dx <= 0) {
                    dx++;
                    
                    const X = cx + dx * xx + dy * xy;
                    const Y = cy + dx * yx + dy * yy;
                    
                    const lSlope = (dx - 0.5) / (dy + 0.5);
                    const rSlope = (dx + 0.5) / (dy - 0.5);
                    
                    if (newStart < rSlope) continue;
                    if (end > lSlope) break;
                    
                    if (dx * dx + dy * dy < radius2) {
                        if (Y >= 0 && Y < fov.length && X >= 0 && X < fov[0].length) {
                            fov[Y][X] = true;
                        }
                    }
                    
                    if (blocked) {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#') {
                            newStart = rSlope;
                            continue;
                        } else {
                            blocked = false;
                            start = newStart;
                        }
                    } else {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#' && j < radius) {
                            blocked = true;
                            Game.castLight(fov, cx, cy, radius, j + 1, start, lSlope,
                                xx, xy, yx, yy);
                            newStart = rSlope;
                        }
                    }
                }
                
                if (blocked) break;
            }
        };

        // ===== MONSTER SYSTEM =====
        // Track extinctions globally
        Game.extinctions = {};
        Game.monsterData = { monsters: [] };

        // Load monster data from JSON file
        Game.loadMonsterData = async function() {
            try {
                const response = await fetch('data/monsters.json');
                Game.monsterData = await response.json();
                console.log(`Loaded ${Game.monsterData.monsters.length} monster types`);
            } catch (error) {
                console.error('Failed to load monsters.json:', error);
                // Fallback to basic monsters if file fails
                Game.monsterData = {
                    monsters: [
                        {id: "goblin", name: "goblin", symbol: "o", color: "#00FF00", mlevel: 1, speed: 12, hit_dice: "1d8", attacks: [{type: "weapon", adtyp: "phys", dam: "1d4"}], frequency: 6, geno_flags: ["geno"], environment_flags: ["dungeon"], extinction_cap: 120, pack_size: "1", ai_pattern: "aggressive", carries: {gold: true}, loot_system: "none"}
                    ]
                };
            }
        };

        // ===== ITEM SYSTEM =====
        // Item data storage - organized by class
        Game.itemData = {
            weapons: [],
            armor: [],
            accessories: [],
            ingredients: [],
            corpses: [],
            potions: [],
            scrolls: [],
            books: [],
            wands: [],
            tools: [],
            gems: [],
            currency: [],
            artifacts: []
        };

        // Load all item data files
        Game.loadItemData = async function() {
            const itemClasses = [
                'weapons', 'armor', 'accessories', 'foods', 'corpses',
                'potions', 'scrolls', 'books', 'wands', 'tools', 
                'gems', 'currency', 'artifacts'
            ];
            
            console.log('Loading item data files...');
            
            for (const itemClass of itemClasses) {
                try {
                    const response = await fetch(`data/objects/${itemClass}.json`);
                    if (!response.ok) {
                        console.warn(`✗ ${itemClass}.json not found, using defaults`);
                        Game.itemData[itemClass] = Game.getDefaultItems(itemClass);
                    } else {
                        const data = await response.json();
                        Game.itemData[itemClass] = data.items || data[itemClass] || [];
                        console.log(`✓ Loaded ${Game.itemData[itemClass].length} ${itemClass}`);
                    }
                } catch (error) {
                    console.error(`Failed to load ${itemClass}.json:`, error);
                    Game.itemData[itemClass] = Game.getDefaultItems(itemClass);
                }
            }
            
            console.log('Item loading complete!');
        };

        // Default items if files don't exist
        Game.getDefaultItems = function(itemClass) {
            const defaults = {
                weapons: [
                    {
                        id: "rusty_dagger",
                        name: "rusty dagger",
                        symbol: ")",
                        prob: 50,
                        weight: 2,
                        cost: 5,
                        min_depth: 1,
                        max_depth: 20,
                        rarity: "common",
                        quiz_tier: 1,
                        base_damage: 2,
                        chain_multipliers: [1, 1, 2, 2, 4],
                        max_chain_length: 5,
                        damage_types: ["pierce"]
                    }
                ],
                armor: [
                    {
                        id: "leather_cap",
                        name: "leather cap",
                        symbol: "[",
                        prob: 40,
                        weight: 2,
                        cost: 8,
                        min_depth: 1,
                        max_depth: 30,
                        rarity: "common",
                        slot: "head",
                        ac_bonus: 1,
                        equip_threshold: 2
                    }
                ],
                ingredients: [
                    {
                        id: "food_ration",
                        name: "food ration",
                        symbol: "%",
                        prob: 80,
                        weight: 1,
                        cost: 2,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        sp_restore: 30,
                        ingredient_type: "basic"
                    }
                ],
                corpses: [],
                potions: [
                    {
                        id: "healing_potion",
                        name: "potion of healing",
                        symbol: "!",
                        prob: 30,
                        weight: 1,
                        cost: 20,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        effect_type: "heal",
                        potency: "2d4+2",
                        quaff_threshold: 2
                    }
                ],
                scrolls: [
                    {
                        id: "identify_scroll",
                        name: "scroll of identify",
                        symbol: "?",
                        prob: 40,
                        weight: 1,
                        cost: 15,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        effect_type: "identify",
                        read_threshold: 3
                    }
                ],
                currency: [
                    {
                        id: "gold_piece",
                        name: "gold piece",
                        symbol: "$",
                        weight: 0,
                        value: 1
                    }
                ]
            };
            
            return defaults[itemClass] || [];
        };

        // Get items by class
        Game.getItemsByClass = function(itemClass) {
            return Game.itemData[itemClass] || [];
        };

        // Item spawning functions
        Game.spawnFloorItems = function(rooms, depth) {
            const items = [];
            const floorClasses = ['weapons', 'armor', 'ingredients', 'potions', 'scrolls', 'gems', 'currency'];
            
            rooms.forEach(room => {
                if (Math.random() < 0.33) {
                    const itemClass = floorClasses[Math.floor(Math.random() * floorClasses.length)];
                    const classItems = Game.getItemsByClass(itemClass);
                    
                    const eligible = classItems.filter(item => 
                        item.min_depth <= depth && 
                        item.max_depth >= depth &&
                        item.rarity === "common"
                    );
                    
                    if (eligible.length === 0) return;
                    
                    const totalProb = eligible.reduce((sum, item) => sum + (item.prob || 10), 0);
                    let pick = Math.random() * totalProb;
                    let selected = null;
                    
                    for (const item of eligible) {
                        pick -= (item.prob || 10);
                        if (pick <= 0) {
                            selected = item;
                            break;
                        }
                    }
                    
                    if (selected) {
                        const x = room.x - 2 + Math.floor(Math.random() * 5);
                        const y = room.y - 2 + Math.floor(Math.random() * 5);
                        
                        items.push({
                            ...selected,
                            x: x,
                            y: y,
                            itemClass: itemClass,
                            identified: false,
                            blessed: Math.random() < 0.1,
                            cursed: Math.random() < (selected.curse_chance || 0.1),
                            enchantment: selected.can_enchant ? Math.floor(Math.random() * 3) - 1 : 0
                        });
                    }
                }
            });
            
            return items;
        };

        Game.dropMonsterLoot = function(monster) {
            const items = [];
            
            // Always drop corpse
            items.push({
                id: `${monster.id}_corpse`,
                name: `${monster.name} corpse`,
                itemClass: 'corpses',
                symbol: '%',
                weight: monster.weight || 10,
                x: monster.x,
                y: monster.y,
                harvest_tier: Math.ceil(monster.mlevel / 2),
                conferred: monster.conferred || []
            });
            
            // Check carries flags for additional loot
            if (monster.carries) {
                if (monster.carries.gold && Math.random() < 0.5) {
                    const goldAmount = Game.Dice.roll(`${monster.mlevel + 1}d10`);
                    items.push({
                        id: 'gold_pieces',
                        name: `${goldAmount} gold pieces`,
                        itemClass: 'currency',
                        symbol: '$',
                        weight: 0,
                        value: goldAmount,
                        x: monster.x,
                        y: monster.y
                    });
                }
                
                if (monster.carries.weapon && Math.random() < 0.3) {
                    const weapons = Game.getItemsByClass('weapons').filter(item => 
                        item.min_depth <= monster.mlevel &&
                        item.rarity === "common"
                    );
                    
                    if (weapons.length > 0) {
                        const weapon = weapons[Math.floor(Math.random() * weapons.length)];
                        items.push({
                            ...weapon,
                            itemClass: 'weapons',
                            x: monster.x,
                            y: monster.y,
                            identified: false,
                            cursed: Math.random() < 0.2
                        });
                    }
                }
            }
            
            return items;
        };
        // ===== MONSTER CLASS =====
        class Monster {
            constructor(monsterDef, x, y) {
                // Copy all definition fields
                Object.assign(this, monsterDef);
                
                // Instance-specific data
                this.x = x;
                this.y = y;
                this.maxHp = Game.Dice.roll(this.hit_dice || "1d8");
                this.hp = this.maxHp;
                this.dead = false;
                this.paralyzeTurns = 0;
                this.aiState = 'normal';  // normal, fleeing, hunting, guarding
                this.fleeThreshold = 0.25;  // Flee when HP below this percentage
                this.lastSeenPlayerX = null;
                this.lastSeenPlayerY = null;
                this.guardX = x;  // Original position to guard
                this.guardY = y;
                this.guardRadius = 5;
                this.smellTrail = [];  // Track player's scent
                this.heardSound = null;  // Last heard sound position
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                }
            }
            
            move() {
                if (this.dead) return;
                if (this.paralyzeTurns > 0) {
                    this.paralyzeTurns--;
                    return;
                }
                
                // Speed check
                const speedRoll = Math.random() * 12;
                if (speedRoll > (this.speed || 12)) return;
                
                // Update AI state
                this.updateAIState();
                
                // AI patterns
                const pattern = this.ai_pattern || 'aggressive';
                switch(pattern) {
                    case 'aggressive':
                        if (this.aiState === 'fleeing') {
                            this.moveFleeing();
                        } else {
                            this.moveAggressive();
                        }
                        break;
                    case 'cowardly':
                        this.moveCowardly();
                        break;
                    case 'territorial':
                        this.moveTerritorial();
                        break;
                    case 'grid':
                        this.moveGrid();
                        break;
                    case 'sessile':
                        break;
                    case 'slow':
                    case 'slow_pursuit':
                        if (Game.turn % 2 === 0) {
                            if (this.aiState === 'fleeing') {
                                this.moveFleeing();
                            } else {
                                this.moveAggressive();
                            }
                        }
                        break;
                    default:
                        this.moveAggressive();
                }
            }
            
            updateAIState() {
                // Check for fleeing condition
                if (this.hp / this.maxHp <= this.fleeThreshold) {
                    if (this.aiState !== 'fleeing') {
                        this.aiState = 'fleeing';
                        Game.addMessage(`The ${this.name} looks badly wounded!`, 'info');
                    }
                    return;
                }
                
                // Can we see the player?
                const canSeePlayer = this.canSeePosition(Game.player.x, Game.player.y);
                if (canSeePlayer) {
                    this.lastSeenPlayerX = Game.player.x;
                    this.lastSeenPlayerY = Game.player.y;
                    this.aiState = 'hunting';
                } else if (this.lastSeenPlayerX !== null) {
                    // Lost sight of player, but remember where they were
                    this.aiState = 'hunting';
                } else {
                    this.aiState = 'normal';
                }
            }
            
            canSeePosition(targetX, targetY) {
                const dx = Math.abs(targetX - this.x);
                const dy = Math.abs(targetY - this.y);
                const distance = Math.max(dx, dy);
                
                // Check sight range (most monsters see 8 squares)
                if (distance > (this.sightRange || 8)) return false;
                
                // Check line of sight
                return this.hasLineOfSight(targetX, targetY);
            }
            
            hasLineOfSight(targetX, targetY) {
                // Simple line-of-sight check
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                
                for (let i = 1; i < steps; i++) {
                    const x = Math.round(this.x + (dx * i / steps));
                    const y = Math.round(this.y + (dy * i / steps));
                    
                    if (Game.dungeon[y] && Game.dungeon[y][x] === '#') {
                        return false;
                    }
                }
                return true;
            }
            
            moveAggressive() {
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                // If we can see the player, move directly toward them
                if (this.canSeePosition(Game.player.x, Game.player.y)) {
                    this.moveToward(Game.player.x, Game.player.y);
                    return;
                }
                
                // If we remember where player was, hunt there
                if (this.aiState === 'hunting' && this.lastSeenPlayerX !== null) {
                    this.huntLastKnownPosition();
                    return;
                }
                
                // If we can smell, follow scent trail
                if (this.canSmell && distance > 10) {
                    const scent = Game.findStrongestScentNearby(this.x, this.y);
                    if (scent && scent.strength > 3) {
                        this.moveToward(scent.x, scent.y);
                        return;
                    }
                }
                
                // Default: wander randomly if too far
                if (distance > 15 && Math.random() < 0.5) {
                    const moves = [[0,1], [0,-1], [1,0], [-1,0]];
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    this.tryMove(this.x + move[0], this.y + move[1]);
                }
            }
            
            moveFleeing() {
                // Run away from player
                const dx = this.x - Game.player.x;
                const dy = this.y - Game.player.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                // If far enough away, stop fleeing
                if (distance > 15) {
                    this.aiState = 'normal';
                    return;
                }
                
                // Find best escape direction
                const moves = [];
                for (let moveX = -1; moveX <= 1; moveX++) {
                    for (let moveY = -1; moveY <= 1; moveY++) {
                        if (moveX === 0 && moveY === 0) continue;
                        
                        const newX = this.x + moveX;
                        const newY = this.y + moveY;
                        
                        if (this.canMoveTo(newX, newY)) {
                            const newDist = Math.abs(newX - Game.player.x) + Math.abs(newY - Game.player.y);
                            moves.push({ x: newX, y: newY, distance: newDist });
                        }
                    }
                }
                
                // Sort by distance (farthest from player first)
                moves.sort((a, b) => b.distance - a.distance);
                
                if (moves.length > 0) {
                    this.tryMove(moves[0].x, moves[0].y);
                }
            }
            
            moveTerritorial() {
                const dx = Math.abs(this.x - this.guardX);
                const dy = Math.abs(this.y - this.guardY);
                const distFromGuard = Math.max(dx, dy);
                
                const playerDx = Math.abs(Game.player.x - this.guardX);
                const playerDy = Math.abs(Game.player.y - this.guardY);
                const playerDistFromGuard = Math.max(playerDx, playerDy);
                
                // If player is in our territory, attack
                if (playerDistFromGuard <= this.guardRadius) {
                    this.moveAggressive();
                } 
                // If we're too far from guard post, return
                else if (distFromGuard > this.guardRadius) {
                    this.moveToward(this.guardX, this.guardY);
                }
                // Otherwise, patrol randomly
                else if (Math.random() < 0.3) {
                    const moves = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    this.tryMove(this.x + move[0], this.y + move[1]);
                }
            }
            
            moveToward(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    moveY = dy > 0 ? 1 : -1;
                }
                
                // Try primary direction
                if (this.tryMove(this.x + moveX, this.y + moveY)) {
                    return;
                }
                
                // Try secondary direction
                if (moveX === 0) {
                    moveX = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                } else {
                    moveY = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                }
                
                this.tryMove(this.x + moveX, this.y + moveY);
            }
            
            huntLastKnownPosition() {
                if (this.lastSeenPlayerX === null) return;
                
                const dx = Math.abs(this.lastSeenPlayerX - this.x);
                const dy = Math.abs(this.lastSeenPlayerY - this.y);
                
                // If we reached last known position, forget it
                if (dx <= 1 && dy <= 1) {
                    this.lastSeenPlayerX = null;
                    this.lastSeenPlayerY = null;
                    this.aiState = 'normal';
                    return;
                }
                
                // Move toward last known position
                this.moveToward(this.lastSeenPlayerX, this.lastSeenPlayerY);
            }
            
            canMoveTo(x, y) {
                if (!Game.canMoveTo(x, y)) {
                    // Check if it's a door
                    if (Game.dungeon[y] && Game.dungeon[y][x] === '+') {
                        return this.canOpenDoors || false;
                    }
                    return false;
                }
                
                // Check for other monsters
                if (Game.getMonsterAt(x, y)) return false;
                
                // Check for player
                if (x === Game.player.x && y === Game.player.y) return false;
                
                return true;
            }

            moveCowardly() {
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                if (distance < 3) {
                    const moveX = dx > 0 ? -1 : (dx < 0 ? 1 : 0);
                    const moveY = dy > 0 ? -1 : (dy < 0 ? 1 : 0);
                    this.tryMove(this.x + moveX, this.y + moveY);
                }
            }
            
            moveGrid() {
                // Grid bugs only move orthogonally
                const moves = [[0,1], [0,-1], [1,0], [-1,0]];
                const validMoves = moves.filter(([dx, dy]) => {
                    const newX = this.x + dx;
                    const newY = this.y + dy;
                    return Game.canMoveTo(newX, newY) && !Game.getMonsterAt(newX, newY);
                });
                
                if (validMoves.length > 0) {
                    const [dx, dy] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    this.tryMove(this.x + dx, this.y + dy);
                }
            }
            
            tryMove(newX, newY) {
                // Check for player
                if (newX === Game.player.x && newY === Game.player.y) {
                    if (this.aiState !== 'fleeing') {
                        this.attack();
                    }
                    return true;
                }
                
                // Check for doors
                if (Game.dungeon[newY] && Game.dungeon[newY][newX] === '+') {
                    if (this.canOpenDoors) {
                        // Open the door
                        Game.dungeon[newY][newX] = "'";
                        Game.addMessage(`The ${this.name} opens a door!`, 'info');
                        return true;
                    } else if (this.canBreakDoors && this.mlevel >= 3) {
                        // Strong monsters can break doors
                        if (Math.random() < 0.3) {
                            Game.dungeon[newY][newX] = '.';
                            Game.addMessage(`The ${this.name} breaks down the door!`, 'warning');
                        }
                        return false;
                    }
                    return false;
                }
                
                // Normal movement
                if (this.canMoveTo(newX, newY)) {
                    // Add current position to smell trail (for tracking)
                    if (this.tracks) {
                        Game.addScentTrail(this.x, this.y);
                    }
                    
                    this.x = newX;
                    this.y = newY;
                    return true;
                }
                
                return false;
            }
            
            attack() {
                if (!this.attacks || this.attacks.length === 0) return;
                
                for (const attack of this.attacks) {
                    // Calculate base damage
                    let damage = Game.Dice.roll(attack.dam || "1d2");
                    
                    // Apply damage based on type
                    switch(attack.adtyp) {
                        case 'phys':
                            // Physical damage - apply directly
                            if (damage > 0) {
                                Game.player.takeDamage(damage);
                                Game.addMessage(`The ${this.name} ${attack.type}s you for ${damage} damage!`, 'danger');
                            }
                            break;
                            
                        case 'poison':
                            // Poison attack
                            if (damage > 0) {
                                Game.player.takeDamage(Math.floor(damage / 2));
                                Game.addMessage(`The ${this.name}'s ${attack.type} is poisonous!`, 'danger');
                                Game.player.applyStatusEffect('poison', 10 + this.mlevel * 2, this.mlevel);
                            }
                            break;
                            
                        case 'disease':
                            // Disease attack
                            if (damage > 0) {
                                Game.player.takeDamage(damage);
                                Game.addMessage(`The ${this.name}'s ${attack.type} is diseased!`, 'danger');
                                if (Math.random() < 0.3) {
                                    Game.player.applyStatusEffect('disease', 50 + this.mlevel * 10, this.mlevel);
                                }
                            }
                            break;
                            
                        case 'paralyze':
                            // Paralysis attack (like floating eye)
                            Game.addMessage(`The ${this.name} gazes at you!`, 'warning');
                            if (Math.random() < 0.5) {
                                Game.player.applyStatusEffect('paralysis', 3 + this.mlevel, 1);
                            }
                            break;
                            
                        case 'shock':
                            // Electrical damage
                            if (damage > 0) {
                                const shockDamage = Game.player.resistances.shock >= 2 ? 0 : 
                                    Math.floor(damage * (1 - Game.player.resistances.shock * 0.5));
                                if (shockDamage > 0) {
                                    Game.player.takeDamage(shockDamage);
                                    Game.addMessage(`The ${this.name} shocks you for ${shockDamage} damage!`, 'danger');
                                    Game.player.applyStatusEffect('shock', 3, 1);
                                    if (Math.random() < 0.2) {
                                        Game.player.applyStatusEffect('stun', 2, 1);
                                    }
                                }
                            }
                            break;
                            
                        case 'fire':
                            // Fire damage
                            if (damage > 0) {
                                const fireDamage = Game.player.resistances.fire >= 2 ? 0 : 
                                    Math.floor(damage * (1 - Game.player.resistances.fire * 0.5));
                                if (fireDamage > 0) {
                                    Game.player.takeDamage(fireDamage);
                                    Game.addMessage(`The ${this.name} burns you for ${fireDamage} damage!`, 'danger');
                                    if (Math.random() < 0.3) {
                                        Game.player.applyStatusEffect('burning', 5, Math.ceil(this.mlevel / 2));
                                    }
                                }
                            }
                            break;
                            
                        case 'cold':
                            // Cold damage
                            if (damage > 0) {
                                const coldDamage = Game.player.resistances.cold >= 2 ? 0 : 
                                    Math.floor(damage * (1 - Game.player.resistances.cold * 0.5));
                                if (coldDamage > 0) {
                                    Game.player.takeDamage(coldDamage);
                                    Game.addMessage(`The ${this.name} freezes you for ${coldDamage} damage!`, 'danger');
                                    Game.player.applyStatusEffect('freezing', 5, 1);
                                }
                            }
                            break;
                            
                        case 'confuse':
                            // Confusion attack
                            Game.addMessage(`The ${this.name} confuses you!`, 'warning');
                            Game.player.applyStatusEffect('confusion', 5 + this.mlevel, 1);
                            break;
                            
                        case 'blind':
                            // Blindness attack
                            Game.addMessage(`The ${this.name} blinds you!`, 'warning');
                            Game.player.applyStatusEffect('blindness', 10 + this.mlevel * 2, 1);
                            break;
                            
                        default:
                            // Unknown damage type, treat as physical
                            if (damage > 0) {
                                Game.player.takeDamage(damage);
                                Game.addMessage(`The ${this.name} ${attack.type}s you for ${damage} damage!`, 'danger');
                            }
                    }
                }
            }
        }

        // ===== SCENT TRAIL SYSTEM =====
        Game.scentTrails = [];
        Game.maxScentAge = 20;  // Scent lasts 20 turns
        
        Game.addScentTrail = function(x, y) {
            Game.scentTrails.push({
                x: x,
                y: y,
                age: 0,
                strength: 10
            });
        };
        
        Game.updateScentTrails = function() {
            // Age all scent trails
            Game.scentTrails = Game.scentTrails.filter(scent => {
                scent.age++;
                scent.strength = Math.max(0, 10 - scent.age);
                return scent.age < Game.maxScentAge;
            });
        };
        
        Game.getScentAtPosition = function(x, y) {
            const scent = Game.scentTrails.find(s => s.x === x && s.y === y);
            return scent ? scent.strength : 0;
        };
        
        Game.findStrongestScentNearby = function(monsterX, monsterY, range = 3) {
            let strongestScent = null;
            let maxStrength = 0;
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const x = monsterX + dx;
                    const y = monsterY + dy;
                    const strength = Game.getScentAtPosition(x, y);
                    
                    if (strength > maxStrength) {
                        maxStrength = strength;
                        strongestScent = { x, y, strength };
                    }
                }
            }
            
            return strongestScent;
        };

        // ===== MONSTER SPAWNING (NetHack-style) =====
        Game.spawnMonster = function(currentLevel, playerLevel = 1, levelType = 'dungeon') {
            // NetHack's zlevel calculation
            const zlevel = Math.max(currentLevel, Math.floor(playerLevel / 2)) + Math.floor(Math.random() * 3);
            
            // Filter eligible monsters
            const eligible = Game.monsterData.monsters.filter(m => {
                if ((m.mlevel || 0) > zlevel + 2) return false;
                if (m.environment_flags && !m.environment_flags.includes(levelType)) return false;
                const extinctCount = Game.extinctions[m.id] || 0;
                if (extinctCount >= (m.extinction_cap || 120)) return false;
                if (m.geno_flags && !m.geno_flags.includes('geno')) return false;
                return true;
            });
            
            if (eligible.length === 0) return null;
            
            // Weighted selection
            const totalFreq = eligible.reduce((sum, m) => sum + (m.frequency || 1), 0);
            let pick = Math.random() * totalFreq;
            let selected = null;
            
            for (const m of eligible) {
                pick -= (m.frequency || 1);
                if (pick <= 0) {
                    selected = m;
                    break;
                }
            }
            
            if (!selected) return null;
            
            // Track extinction
            Game.extinctions[selected.id] = (Game.extinctions[selected.id] || 0) + 1;
            
            // Find spawn location
            const pos = Game.findSpawnLocation();
            if (!pos) return null;
            
            // Handle pack spawning
            const packSize = Game.Dice.roll(selected.pack_size || "1");
            const monsters = [];
            
            for (let i = 0; i < packSize; i++) {
                const spawnPos = i === 0 ? pos : Game.findNearbySpawnLocation(pos.x, pos.y);
                if (spawnPos) {
                    monsters.push(new Monster(selected, spawnPos.x, spawnPos.y));
                }
            }
            
            return monsters;
        };
        
        Game.findSpawnLocation = function() {
            for (let attempts = 0; attempts < 100; attempts++) {
                const x = Math.floor(Math.random() * Game.config.mapWidth);
                const y = Math.floor(Math.random() * Game.config.mapHeight);
                
                // Check bounds first, THEN access the array
                if (y >= 0 && y < Game.config.mapHeight && 
                    x >= 0 && x < Game.config.mapWidth &&
                    Game.dungeon[y] && Game.dungeon[y][x] === '.' &&
                    !Game.getMonsterAt(x, y) && 
                    !(x === Game.player.x && y === Game.player.y)) {
                    const dist = Math.abs(x - Game.player.x) + Math.abs(y - Game.player.y);
                    if (dist > 10) return { x, y };
                }
            }
            return null;
        };
        
        Game.findNearbySpawnLocation = function(centerX, centerY) {
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (Game.dungeon[y] && Game.dungeon[y][x] === '.' &&
                        !Game.getMonsterAt(x, y) && 
                        !(x === Game.player.x && y === Game.player.y)) {
                        return { x, y };
                    }
                }
            }
            return null;
        };

        // ===== DUNGEON GENERATION =====
        function generateDungeon(width, height) {
            const dungeon = [];
            
            // Initialize with walls
            for (let y = 0; y < height; y++) {
                dungeon[y] = [];
                for (let x = 0; x < width; x++) {
                    dungeon[y][x] = '#';
                }
            }
            
            // Generate rooms
            const rooms = [];
            const numRooms = 5 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < numRooms; i++) {
                const roomWidth = 5 + Math.floor(Math.random() * 10);
                const roomHeight = 5 + Math.floor(Math.random() * 6);
                const roomX = 1 + Math.floor(Math.random() * (width - roomWidth - 2));
                const roomY = 1 + Math.floor(Math.random() * (height - roomHeight - 2));
                
                // Carve room
                for (let y = roomY; y < roomY + roomHeight; y++) {
                    for (let x = roomX; x < roomX + roomWidth; x++) {
                        dungeon[y][x] = '.';
                    }
                }
                
                rooms.push({
                    x: roomX + Math.floor(roomWidth / 2),
                    y: roomY + Math.floor(roomHeight / 2),
                    width: roomWidth,
                    height: roomHeight
                });
            }
            
            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                
                // Horizontal then vertical
                const startX = Math.min(room1.x, room2.x);
                const endX = Math.max(room1.x, room2.x);
                for (let x = startX; x <= endX; x++) {
                    dungeon[room1.y][x] = '.';
                }
                
                const startY = Math.min(room1.y, room2.y);
                const endY = Math.max(room1.y, room2.y);
                for (let y = startY; y <= endY; y++) {
                    dungeon[y][room2.x] = '.';
                }
            }
            
            // Place player in first room
            if (rooms.length > 0) {
                // Always place up stairs at spawn on level 1
                if (Game.currentLevel === 1) {
                    dungeon[rooms[0].y][rooms[0].x] = '<';
                }
                Game.player.x = rooms[0].x;
                Game.player.y = rooms[0].y;
            }

            // Place stairs in last room
            if (rooms.length > 1) {
                const lastRoom = rooms[rooms.length - 1];
                dungeon[lastRoom.y][lastRoom.x] = '>';
            }
            
            if (Game.currentLevel > 1 && rooms.length > 0) {
                dungeon[rooms[0].y][rooms[0].x] = '<';
            }
            // Spawn items using new system
            Game.items = Game.spawnFloorItems(rooms, Game.currentLevel);
            
            return dungeon;
        }

        // ===== RENDERING =====
        function render() {
            if (!Game.display || !Game.dungeon || !Game.player) return;
            
            // Calculate field of view
            const fov = Game.calculateFOV();
            
            // Build display with HTML for colors
            let displayHTML = '';
            
            for (let y = 0; y < Game.config.mapHeight; y++) {
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    let char = ' ';
                    let color = '#222'; // Dark gray for unseen
                    
                    // Only render if in FOV
                    if (!fov[y] || !fov[y][x]) {
                        // Show remembered walls in dark gray
                        if (Game.remembered && Game.remembered[y] && Game.remembered[y][x] === '#') {
                            char = '#';
                            color = '#333';
                        } else {
                            char = ' ';
                        }
                    } else {
                        // Remember terrain
                        if (!Game.remembered) Game.remembered = [];
                        if (!Game.remembered[y]) Game.remembered[y] = [];
                        if (Game.dungeon[y] && Game.dungeon[y][x]) {
                            Game.remembered[y][x] = Game.dungeon[y][x];
                        }
                        
                        // Player
                        if (x === Game.player.x && y === Game.player.y) {
                            char = '@';
                            color = '#fff'; // White for player
                        }
                        // Monsters
                        else {
                            let hasMonster = false;
                            for (const monster of Game.monsters) {
                                if (!monster.dead && monster.x === x && monster.y === y) {
                                    char = monster.symbol;
                                    color = monster.color;
                                    hasMonster = true;
                                    break;
                                }
                            }
                            
                            if (!hasMonster) {
                                // Items
                                let hasItem = false;
                                for (const item of Game.items) {
                                    if (item.x === x && item.y === y) {
                                        char = item.symbol;
                                        // Item colors
                                        switch(item.type) {
                                            case 'food':
                                            case 'corpse':
                                                color = '#8b4513'; // Brown
                                                break;
                                            case 'weapon':
                                                color = '#c0c0c0'; // Silver
                                                break;
                                            case 'armor':
                                                color = '#4682b4'; // Steel blue
                                                break;
                                            case 'potion':
                                                color = '#ff1493'; // Deep pink
                                                break;
                                            default:
                                                color = '#ffd700'; // Gold
                                        }
                                        hasItem = true;
                                        break;
                                    }
                                }
                                
                                if (!hasItem) {
                                    // Terrain
                                    if (Game.dungeon[y] && Game.dungeon[y][x]) {
                                        char = Game.dungeon[y][x];
                                        // Terrain colors
                                        switch(char) {
                                            case '#':
                                                color = '#888'; // Light gray walls
                                                break;
                                            case '.':
                                                color = '#666'; // Dark gray floor
                                                break;
                                            case '>':
                                                color = '#ff0'; // Yellow stairs
                                                break;
                                            case '+':
                                                color = '#8b4513'; // Brown door
                                                break;
                                            default:
                                                color = '#666';
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    displayHTML += `<span style="color:${color}">${char}</span>`;
                }
                displayHTML += '\n';
            }
            
            Game.display.innerHTML = displayHTML;
            updateUI();
        }

        // ===== UI UPDATES =====
        function updateUI() {
            const player = Game.player;
            if (!player) return;
            
            // Update bars
            document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('hp-text').textContent = `HP: ${player.hp}/${player.maxHp}`;
            
            document.getElementById('sp-bar').style.width = (player.sp / player.maxSp * 100) + '%';
            document.getElementById('sp-text').textContent = `SP: ${player.sp}/${player.maxSp}`;
            
            document.getElementById('mp-bar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mp-text').textContent = `MP: ${player.mp}/${player.maxMp}`;
            
            // Update attributes
            document.getElementById('str').textContent = player.strength;
            document.getElementById('con').textContent = player.constitution;
            document.getElementById('dex').textContent = player.dexterity;
            document.getElementById('int').textContent = player.intelligence;
            document.getElementById('wis').textContent = player.wisdom;
            document.getElementById('per').textContent = player.perception;
            
            // Update status
            document.getElementById('ac').textContent = player.getAC();
            document.getElementById('sight').textContent = player.getSightRadius();
            document.getElementById('timer').textContent = player.getQuizTimer();
            document.getElementById('current-weight').textContent = player.currentWeight;
            document.getElementById('max-weight').textContent = player.maxCarry;
            document.getElementById('dungeon-level').textContent = Game.currentLevel;
            
            // Hunger status
            const hungerStatus = player.getHungerStatus();
            document.getElementById('hunger-status').textContent = hungerStatus;
            
            // Burden status
            const burdenStatus = player.getBurdenStatus();
            document.getElementById('burden-status').textContent = burdenStatus;
            
            // Status effects display
            const statusEffects = [];
            if (player.statusFlags.isPoisoned) statusEffects.push('Poisoned');
            if (player.statusFlags.isSick) statusEffects.push('Sick');
            if (player.statusFlags.isParalyzed) statusEffects.push('Paralyzed');
            if (player.statusFlags.isStunned) statusEffects.push('Stunned');
            if (player.statusFlags.isConfused) statusEffects.push('Confused');
            if (player.statusFlags.isBlind) statusEffects.push('Blind');
            if (player.statusEffects.burning.duration > 0) statusEffects.push('Burning');
            if (player.statusEffects.freezing.duration > 0) statusEffects.push('Frozen');
            if (player.statusEffects.shock.duration > 0) statusEffects.push('Shocked');
            
            const statusDiv = document.getElementById('status-effects');
            if (statusEffects.length > 0) {
                statusDiv.innerHTML = statusEffects.map(effect => 
                    `<span style="color: var(--health-red);">${effect}</span>`
                ).join(' ');
            } else {
                statusDiv.innerHTML = '';
            }

            // Inventory
            const invList = document.getElementById('inventory-list');
            if (player.inventory.length === 0) {
                invList.innerHTML = '<div class="inventory-item">Empty</div>';
            } else {
                invList.innerHTML = player.inventory.map(item => 
                    `<div class="inventory-item">${item.letter}) ${item.name}${item.identified ? '' : ' (?)'}</div>`
                ).join('');
            }
        }

        // ===== MESSAGE LOG =====
        Game.addMessage = function(text, type = 'info') {
            const messageLog = document.getElementById('message-log');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            
            messageLog.appendChild(message);
            messageLog.scrollTop = messageLog.scrollHeight;
            
            // Limit messages
            while (messageLog.children.length > Game.maxMessages) {
                messageLog.removeChild(messageLog.firstChild);
            }
        };

        // ===== INPUT HANDLING =====
        Game.handleKeyPress = function(e) {
            // Don't handle input during quiz
            if (Game.QuizEngine.isActive || document.getElementById('quiz-modal').classList.contains('active')) return;
            
            let dx = 0, dy = 0;
            
            // Movement keys
            switch(e.key) {
                // Arrow key movement
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                
                // Numpad diagonal movement
                case '7': dx = -1; dy = -1; break;  // NW
                case '8': dy = -1; break;           // N
                case '9': dx = 1; dy = -1; break;   // NE
                case '4': dx = -1; break;           // W
                case '6': dx = 1; break;            // E
                case '1': dx = -1; dy = 1; break;   // SW
                case '2': dy = 1; break;            // S
                case '3': dx = 1; dy = 1; break;    // SE
                
                // Wait
                case '5':
                case '.':
                case ' ':
                    Game.addMessage("You wait.", 'info');
                    Game.player.spendSP(1);
                    Game.processTurn();
                    return;
                
                // Item management
                case ',':
                case 'g':
                    Game.pickupItem();
                    Game.processTurn();
                    return;
                case 'd':
                    Game.dropItem();
                    return;
                case 'D':
                    Game.dropMultiple();
                    return;
                case 'i':
                    Game.addMessage("There is no inventory command, only Zuul.", 'warning');
                    return;
                
                // Equipment & Combat
                case 'e':
                    Game.promptEquip();
                    return;
                case 'E':
                    Game.promptUnequip();
                    return;
                case 'f':
                    Game.addMessage("There is no fire command, only Zuul.", 'warning');
                    return;
                
                // Food system
                case 'h':
                    Game.playerHarvest();
                    return;
                case 'c':
                    Game.playerCook();
                    return;
                
                // Magic items
                case 'r':
                    Game.addMessage("There is no read command, only Zuul.", 'warning');
                    return;
                case 'q':
                    Game.addMessage("There is no quaff command, only Zuul.", 'warning');
                    return;
                case 'z':
                    Game.addMessage("There is no zap command, only Zuul.", 'warning');
                    return;
                case 'C':
                    Game.addMessage("There is no cast command, only Zuul.", 'warning');
                    return;
                
                // Special actions
                case 'I':
                    Game.addMessage("There is no identify command, only Zuul.", 'warning');
                    return;
                case 'p':
                    Game.addMessage("There is no pray command, only Zuul.", 'warning');
                    return;
                case 'l':
                    Game.addMessage("There is no lockpick command, only Zuul.", 'warning');
                    return;

                // Help
                case '?':
                    Game.showHelp();
                    return;

                // Stairs
                case '>':
                    if (Game.dungeon[Game.player.y][Game.player.x] === '>') {
                        Game.nextLevel();
                    } else {
                        Game.addMessage("There are no stairs here.", 'warning');
                    }
                    return;
                case '<':
                    if (Game.dungeon[Game.player.y][Game.player.x] === '<') {
                        if (Game.currentLevel === 1) {
                            Game.attemptExit();
                        } else {
                            Game.prevLevel();
                        }
                    } else {
                        Game.addMessage("There are no up stairs here.", 'warning');
                    }
                    return;
            }
            
            // Process movement
            if (dx !== 0 || dy !== 0) {
                Game.movePlayer(dx, dy);
                e.preventDefault();
            }
        };

        Game.movePlayer = function(dx, dy) {
            // Handle confusion - randomize movement
            if (Game.player.statusFlags.isConfused && Math.random() < 0.75) {
                const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                const confused = directions[Math.floor(Math.random() * directions.length)];
                dx = confused[0];
                dy = confused[1];
                Game.addMessage("You stumble around in confusion!", 'warning');
            }
            
            // Handle paralysis - can't move
            if (Game.player.statusFlags.isParalyzed) {
                Game.addMessage("You are paralyzed and cannot move!", 'danger');
                Game.player.spendSP(1);
                Game.processTurn();
                return;
            }
            
            // Handle stun - chance to fail movement
            if (Game.player.statusFlags.isStunned && Math.random() < 0.5) {
                Game.addMessage("You are too stunned to move properly!", 'warning');
                Game.player.spendSP(1);
                Game.processTurn();
                return;
            }

            const player = Game.player;
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Check for monster
            const monster = Game.getMonsterAt(newX, newY);
            if (monster && !monster.dead) {
                Game.playerAttack(monster);
                return;
            }
            
            // Check if can move
            if (!Game.canMoveTo(newX, newY)) {
                Game.addMessage("You can't move there!", 'warning');
                return;
            }
            
            // Move player
            player.x = newX;
            player.y = newY;
            player.spendSP(1);
            
            // Check for items at new position
            const itemsHere = Game.items.filter(i => i.x === player.x && i.y === player.y);
            if (itemsHere.length > 0) {
                if (itemsHere.length === 1) {
                    Game.addMessage(`You see a ${itemsHere[0].name} here.`, 'info');
                } else {
                    Game.addMessage(`You see several items here.`, 'info');
                }
            }

            // Check for stairs
            if (Game.dungeon[newY][newX] === '>') {
                Game.addMessage("You see stairs leading down. Press > to descend.", 'info');
            }
            
            Game.processTurn();
        };

        Game.canMoveTo = function(x, y) {
            if (y < 0 || y >= Game.dungeon.length) return false;
            if (x < 0 || x >= Game.dungeon[y].length) return false;
            return Game.dungeon[y][x] !== '#';
        };

        Game.getMonsterAt = function(x, y) {
            return Game.monsters.find(m => !m.dead && m.x === x && m.y === y);
        };

        Game.processTurn = function() {
            // Add player's scent trail
            Game.addScentTrail(Game.player.x, Game.player.y);
            
            // Process player status effects
            Game.player.processStatusEffects();
            
            // Update scent trails
            Game.updateScentTrails();
            
            // Move monsters (unless player is paralyzed)
            if (!Game.player.statusFlags.isParalyzed) {
                Game.monsters.forEach(m => m.move());
            }
            
            // Increment turn
            Game.turn++;
            
            // Render
            render();
        };

        Game.playerAttack = function(monster) {
            // Special case: attacking floating eye causes paralysis
            if (monster.id === 'floating_eye' && !monster.dead) {
                if (Math.random() < 0.66) {  // 66% chance
                    Game.addMessage(`You gaze into the floating eye and are paralyzed!`, 'danger');
                    Game.player.applyStatusEffect('paralysis', 5 + monster.mlevel, 1);
                    Game.processTurn();
                    return;
                }
            }

            const weapon = Game.player.equipped.weapon || {
                // Default unarmed stats
                quiz_tier: 1,
                max_chain_length: 5,
                base_damage: 1000,
                chain_multipliers: [1, 1.5, 2, 2.5, 3]
            };
            
            Game.QuizEngine.startQuiz({
                mode: 'chain',
                subject: 'math',
                startingTier: weapon.quiz_tier || 1,
                maxChain: weapon.max_chain_length || 5,
                reason: `Attacking ${monster.name}`,
                target: monster,
                callback: function(result) {
                    if (result.score > 0) {
                        // Use chain_multipliers if available, otherwise basic calculation
                        const multiplier = weapon.chain_multipliers ? 
                            (weapon.chain_multipliers[result.score - 1] || weapon.chain_multipliers[weapon.chain_multipliers.length - 1]) : 
                            result.score;
                        const damage = Math.floor(weapon.base_damage * multiplier);
                        
                        monster.takeDamage(damage);
                        Game.addMessage(`You hit the ${monster.name} for ${damage} damage!`, 'success');
                        
                        if (monster.dead) {
                            Game.addMessage(`The ${monster.name} dies!`, 'success');
                            Game.dropCorpse(monster);
                        }
                    } else {
                        Game.addMessage(`You miss the ${monster.name}!`, 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // FIRE - Ranged attack
        Game.playerFire = function() {
            // TODO: Implement targeting system
            Game.addMessage("Ranged weapons not yet implemented!", 'warning');
            return;
            
            /* Future implementation:
            const weapon = Game.player.equipped.weapon;
            if (!weapon || weapon.type !== 'ranged') {
                Game.addMessage("You need a ranged weapon equipped!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'chain',
                subject: 'math',  // or 'physics' for advanced weapons
                startingTier: weapon.quiz_tier || 1,
                maxChain: weapon.max_chain_length || 5,
                reason: 'Firing ' + weapon.name,
                callback: function(result) {
                    // Handle ranged damage
                }
            });
            */
        };

        // EQUIP - Put on armor or accessories
        Game.playerEquip = function(item) {
            if (!item) {
                Game.addMessage("What do you want to equip?", 'info');
                return;
            }
            
            // Determine quiz subject based on item type
            let subject = 'geography';  // default for armor
            if (item.class === 'ring' || item.class === 'amulet') {
                subject = 'history';  // accessories use history
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: subject,
                startingTier: item.quiz_tier || 1,
                threshold: item.equip_threshold || 3,
                reason: `Equipping ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Actually equip the item
                        Game.addMessage(`You equip the ${item.name}.`, 'success');
                    } else {
                        Game.addMessage(`You fail to equip the ${item.name}.`, 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // ===== HARVEST SYSTEM =====
        Game.corpseData = {};
        
        // Load corpse data
        Game.loadCorpseData = async function() {
            try {
                const response = await fetch('data/objects/corpses.json');
                if (!response.ok) {
                    console.warn('corpses.json not found, using defaults');
                    Game.corpseData = Game.getDefaultCorpses();
                } else {
                    const data = await response.json();
                    // Index by ID for quick lookup
                    Game.corpseData = {};
                    (data.corpses || data.items || []).forEach(corpse => {
                        Game.corpseData[corpse.id] = corpse;
                    });
                    console.log(`Loaded ${Object.keys(Game.corpseData).length} corpse types`);
                }
            } catch (error) {
                console.error('Failed to load corpses.json:', error);
                Game.corpseData = Game.getDefaultCorpses();
            }
        };
        
        // Default corpses if file missing
        Game.getDefaultCorpses = function() {
            return {
                "giant_rat_corpse": {
                    id: "giant_rat_corpse",
                    name: "giant rat corpse",
                    weight: 5,
                    harvest_tier: 1,
                    harvest_threshold: 2,
                    harvest_food: "rat_meat",
                    food_name: "stringy rat meat"
                },
                "goblin_corpse": {
                    id: "goblin_corpse",
                    name: "goblin corpse",
                    weight: 40,
                    harvest_tier: 1,
                    harvest_threshold: 3,
                    harvest_food: "goblin_jerky",
                    food_name: "tough goblin jerky"
                }
            };
        };
        
        // ===== FOOD DATA SYSTEM =====
        Game.foodData = {};

        // Load food data
        Game.loadFoodData = async function() {
            try {
                const response = await fetch('data/objects/foods.json');
                if (!response.ok) {
                    console.warn('foods.json not found, using defaults');
                    Game.foodData = Game.getDefaultFoods();
                } else {
                    const data = await response.json();
                    // Index by ID for quick lookup
                    Game.foodData = {};
                    (data.foods || []).forEach(food => {
                        Game.foodData[food.id] = food;
                    });
                    console.log(`Loaded ${Object.keys(Game.foodData).length} food types`);
                }
            } catch (error) {
                console.error('Failed to load foods.json:', error);
                Game.foodData = Game.getDefaultFoods();
            }
        };

        // Default foods if file missing
        Game.getDefaultFoods = function() {
            return {
                "rat_meat": {
                    id: "rat_meat",
                    name: "stringy rat meat",
                    recipes: {
                        "0": {name: "ruined rat slop", sp: 0},
                        "1": {name: "rat jerky", sp: 20},
                        "2": {name: "fried rat bits", sp: 40},
                        "3": {name: "BBQ rat skewers", sp: 60, strength: 1},
                        "4": {name: "rat wellington", sp: 80, strength: 1},
                        "5": {name: "sublime rat confit", sp: 100, strength: 2, constitution: 1}
                    }
                }
            };
        };

        // Main harvest function - only works on ground
        Game.playerHarvest = function() {
            // Check for corpses at player location
            const corpsesHere = Game.items.filter(item => 
                item.x === Game.player.x && 
                item.y === Game.player.y && 
                item.itemClass === 'corpses'
            );
            
            if (corpsesHere.length === 0) {
                Game.addMessage("There are no corpses here to harvest!", 'warning');
                Game.addMessage("Drop a corpse here first if you want to harvest it.", 'info');
                return;
            }
            
            // Harvest first corpse at location
            const corpse = corpsesHere[0];
            const corpseData = Game.corpseData[corpse.id];
            
            if (!corpseData) {
                Game.addMessage(`You don't know how to harvest ${corpse.name}!`, 'warning');
                return;
            }
            
            // Store harvest state
            Game.harvestingCorpse = corpse;
            
            // Start animal quiz
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'animal',
                startingTier: corpseData.harvest_tier || 1,
                threshold: corpseData.harvest_threshold || 3,
                reason: `Harvesting ${corpse.name}`,
                target: corpse,
                callback: function(result) {
                    Game.handleHarvestResult(result);
                }
            });
        };
        
        // Handle harvest quiz result
        Game.handleHarvestResult = function(result) {
            const corpse = Game.harvestingCorpse;
            const corpseData = Game.corpseData[corpse.id];
            
            // Remove corpse from ground either way
            Game.items = Game.items.filter(item => item !== corpse);
            
            if (result.success) {
                // Look up the food data
                const foodData = Game.foodData[corpseData.harvest_food];
                
                if (!foodData) {
                    Game.addMessage(`You don't know how to harvest ${corpse.name}!`, 'warning');
                    return;
                }
                
                const foodItem = {
                    id: corpseData.harvest_food,  // This ID matches the key in foodData
                    name: foodData.name,
                    itemClass: 'ingredients',  // Just a label meaning "this can be cooked"
                    symbol: '%',
                    weight: foodData.weight,
                    identified: true
                };
                
                // Try to add to inventory
                if (Game.player.addToInventory(foodItem)) {
                    Game.addMessage(`You expertly harvest ${foodItem.name} from the corpse!`, 'success');
                } else {
                    // Drop on ground if can't carry
                    foodItem.x = Game.player.x;
                    foodItem.y = Game.player.y;
                    Game.items.push(foodItem);
                    Game.addMessage(`You harvest ${foodItem.name} but can't carry it!`, 'warning');
                }
            } else {
                // Failed - corpse is ruined
                Game.addMessage("You butcher the corpse badly, ruining any usable meat!", 'danger');
            }
            
            // Clear harvest state
            Game.harvestingCorpse = null;
            Game.processTurn();
        };

        // COOK - Create meals from ingredients
        Game.playerCook = function() {
            // Check inventory for cookable ingredients
            const ingredients = Game.player.inventory.filter(item => 
                item.itemClass === 'ingredients'
            );
            
            if (ingredients.length === 0) {
                Game.addMessage("You have no ingredients to cook!", 'warning');
                return;
            }
            
            // Build menu items
            const menuItems = ingredients.map(ingredient => {
                const foodData = Game.foodData[ingredient.id];
                let description = '';
                
                if (foodData && foodData.recipes) {
                    const bestRecipe = foodData.recipes["5"] || foodData.recipes["4"] || foodData.recipes["3"];
                    if (bestRecipe) {
                        description = `Can become: ${bestRecipe.name}`;
                    }
                }
                
                return {
                    name: ingredient.name,
                    description: description,
                    data: ingredient
                };
            });
            
            // Show menu
            Game.MenuSystem.show(
                'COOKING STATION',
                menuItems,
                (selected) => {
                    Game.startCooking(selected.data);
                },
                'Choose an ingredient to cook'
            );
        };

        // Handle cooking quiz result
        Game.handleCookingResult = function(result) {
            const ingredient = Game.cookingIngredient;
            const foodData = Game.foodData[ingredient.id];
            
            // Remove ingredient from inventory
            Game.player.removeFromInventory(ingredient);
            
            const quality = result.score;
            const recipe = foodData.recipes[quality.toString()];
            
            if (!recipe) {
                Game.addMessage("Cooking error - no recipe found!", 'danger');
                return;
            }
            
            // Create the cooked meal
            Game.addMessage(`You create ${recipe.name}!`, quality === 0 ? 'danger' : 'success');
            
            // Auto-consume and apply effects
            if (recipe.sp) {
                Game.player.restoreSP(recipe.sp);
                Game.addMessage(`You restore ${recipe.sp} stamina!`, 'success');
            }
            
            // Apply permanent stat gains
            if (recipe.strength) {
                Game.player.strength += recipe.strength;
                Game.addMessage(`Your strength increases by ${recipe.strength}!`, 'loot');
            }
            if (recipe.constitution) {
                Game.player.constitution += recipe.constitution;
                // Recalculate HP/SP maximums
                Game.player.maxHp = Game.config.baseHP + Math.floor((Game.player.constitution - 10) / 2);
                Game.player.maxSp = Game.config.baseSP + (Game.player.constitution - 10) * 2;
                Game.addMessage(`Your constitution increases by ${recipe.constitution}!`, 'loot');
            }
            if (recipe.dexterity) {
                Game.player.dexterity += recipe.dexterity;
                Game.addMessage(`Your dexterity increases by ${recipe.dexterity}!`, 'loot');
            }
            if (recipe.intelligence) {
                Game.player.intelligence += recipe.intelligence;
                // Recalculate MP maximum
                Game.player.maxMp = Game.config.baseMP + Math.floor((Game.player.intelligence - 10) / 2);
                Game.addMessage(`Your intelligence increases by ${recipe.intelligence}!`, 'loot');
            }
            if (recipe.wisdom) {
                Game.player.wisdom += recipe.wisdom;
                Game.addMessage(`Your wisdom increases by ${recipe.wisdom}!`, 'loot');
            }
            if (recipe.perception) {
                Game.player.perception += recipe.perception;
                Game.addMessage(`Your perception increases by ${recipe.perception}!`, 'loot');
            }
            if (recipe.all_stats) {
                Game.player.strength += recipe.all_stats;
                Game.player.constitution += recipe.all_stats;
                Game.player.dexterity += recipe.all_stats;
                Game.player.intelligence += recipe.all_stats;
                Game.player.wisdom += recipe.all_stats;
                Game.player.perception += recipe.all_stats;
                // Recalculate derived stats
                Game.player.maxHp = Game.config.baseHP + Math.floor((Game.player.constitution - 10) / 2);
                Game.player.maxSp = Game.config.baseSP + (Game.player.constitution - 10) * 2;
                Game.player.maxMp = Game.config.baseMP + Math.floor((Game.player.intelligence - 10) / 2);
                Game.addMessage(`All your attributes increase by ${recipe.all_stats}!`, 'loot');
            }
            if (recipe.maxHp) {
                Game.player.maxHp += recipe.maxHp;
                Game.player.hp = Math.min(Game.player.hp, Game.player.maxHp);
                Game.addMessage(`Your maximum HP increases by ${recipe.maxHp}!`, 'loot');
            }
            if (recipe.maxSp) {
                Game.player.maxSp += recipe.maxSp;
                Game.addMessage(`Your maximum SP increases by ${recipe.maxSp}!`, 'loot');
            }
            
            // Apply temporary effects if any
            if (recipe.effect) {
                Game.addMessage(`You gain the ${recipe.effect} effect!`, 'info');
                // TODO: Implement temporary effects system
            }
            
            // Clear cooking state
            Game.cookingIngredient = null;
            Game.processTurn();
        };

        // Start cooking the selected ingredient
        Game.startCooking = function(ingredient) {
            // Hide cooking modal
            document.getElementById('cooking-modal').classList.remove('active');
            
            const foodData = Game.foodData[ingredient.id];
            
            if (!foodData) {
                Game.addMessage(`You don't know how to cook ${ingredient.name}!`, 'warning');
                return;
            }
            
            // Store cooking state
            Game.cookingIngredient = ingredient;
            
            // Start cooking quiz
            Game.QuizEngine.startQuiz({
                mode: 'escalator_chain',
                subject: 'cooking',
                startingTier: foodData.tier || 1,
                maxChain: 5,  // 5 quality levels max (0-5 = 6 total outcomes)
                reason: `Cooking ${ingredient.name}`,
                target: ingredient,
                callback: function(result) {
                    Game.handleCookingResult(result);
                }
            });
        };

        // Cancel cooking
        Game.cancelCooking = function() {
            document.getElementById('cooking-modal').classList.remove('active');
            Game.addMessage("You decide not to cook right now.", 'info');
        };

        // CAST - Cast spell from memory
        Game.playerCast = function(spell) {
            if (!spell) {
                Game.addMessage("You don't know any spells!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: spell.quiz_mode || 'chain',
                subject: 'science',
                startingTier: spell.tier || 1,
                threshold: spell.threshold,
                maxChain: spell.max_chain,
                reason: `Casting ${spell.name}`,
                target: spell,
                callback: function(result) {
                    if (result.success || result.score > 0) {
                        // TODO: Apply spell effects
                        Game.addMessage(`You cast ${spell.name}!`, 'success');
                    } else {
                        Game.addMessage("The spell fizzles!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // READ - Read scroll or book
        Game.playerRead = function(item) {
            if (!item || (item.type !== 'scroll' && item.type !== 'book')) {
                Game.addMessage("That's not readable!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'grammar',
                startingTier: item.quiz_tier || 1,
                threshold: item.read_threshold || 3,
                reason: `Reading ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Trigger scroll effect or learn spell
                        Game.addMessage(`You successfully read the ${item.name}!`, 'success');
                    } else {
                        Game.addMessage("You can't comprehend the text!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // ZAP - Use wand or staff
        Game.playerZap = function(item) {
            if (!item || (item.type !== 'wand' && item.type !== 'staff')) {
                Game.addMessage("That's not a wand or staff!", 'warning');
                return;
            }
            
            if ((item.charges || 0) <= 0) {
                Game.addMessage("It has no charges left!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'science',  // or 'math' for some wands
                startingTier: item.quiz_tier || 1,
                threshold: item.zap_threshold || 2,
                reason: `Zapping ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Apply wand effect
                        item.charges--;
                        Game.addMessage(`You zap the ${item.name}! (${item.charges} charges left)`, 'success');
                    } else {
                        Game.addMessage("Nothing happens!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // IDENTIFY - Reveal item properties (requires Philosopher's Amulet)
        Game.playerIdentify = function(item) {
            const hasAmulet = Game.player.equipped.accessories?.amulet?.id === 'philosophers_amulet';
            if (!hasAmulet) {
                Game.addMessage("You need the Philosopher's Amulet to identify items!", 'warning');
                return;
            }
            
            if (!item || item.identified) {
                Game.addMessage("That doesn't need identification!", 'info');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'philosophy',
                startingTier: item.quiz_tier || 1,
                threshold: item.identify_threshold || Game.Dice.roll('1d3+2'),  // 3-5
                reason: `Identifying ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        item.identified = true;
                        // TODO: Reveal BUC status, enchantments, etc.
                        Game.addMessage(`You identify the ${item.name}!`, 'success');
                    } else {
                        Game.addMessage("The item's nature remains mysterious.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // QUAFF - Drink potion
        Game.playerQuaff = function(potion) {
            if (!potion || potion.type !== 'potion') {
                Game.addMessage("That's not a potion!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'chemistry',  // Note: Need to add chemistry questions
                startingTier: potion.quiz_tier || 1,
                threshold: potion.quaff_threshold || 2,
                reason: `Drinking ${potion.name}`,
                target: potion,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Apply potion effects
                        Game.addMessage(`You drink the ${potion.name}!`, 'success');
                        Game.player.removeFromInventory(potion);
                    } else {
                        Game.addMessage("You fail to drink it properly and it spills!", 'warning');
                        Game.player.removeFromInventory(potion);
                    }
                    Game.processTurn();
                }
            });
        };

        // LOCKPICK - Open containers or doors
        Game.playerLockpick = function(target) {
            if (!target || (!target.locked && target.type !== 'door')) {
                Game.addMessage("That's not locked!", 'info');
                return;
            }
            
            const threshold = target.lock_difficulty || Game.Dice.roll('2d4');  // 2-8
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'economics',
                startingTier: target.lock_tier || 1,
                threshold: threshold,
                reason: `Picking lock`,
                target: target,
                callback: function(result) {
                    if (result.success) {
                        target.locked = false;
                        Game.addMessage("You pick the lock successfully!", 'success');
                        
                        // Check for traps (50% chance on containers)
                        if (target.type === 'container' && Math.random() < 0.5) {
                            Game.addMessage("It was trapped! You take damage!", 'danger');
                            Game.player.takeDamage(Game.Dice.roll('2d6'));
                        }
                    } else {
                        Game.addMessage("You fail to pick the lock.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // PRAY - Divine intervention
        Game.playerPray = function() {
            // TODO: Check if at altar or if enough time has passed
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'theology',  // Note: Need to add theology questions
                startingTier: 1,
                threshold: 3,
                reason: 'Praying for divine aid',
                callback: function(result) {
                    if (result.success) {
                        // TODO: Random beneficial effect
                        Game.addMessage("You feel the presence of the divine!", 'success');
                    } else {
                        Game.addMessage("Your prayers go unanswered.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        Game.dropCorpse = function(monster) {
            const loot = Game.dropMonsterLoot(monster);
            Game.items.push(...loot);
            
            loot.forEach(item => {
                if (item.itemClass === 'corpses') {
                    Game.addMessage(`The ${monster.name} leaves a corpse.`, 'info');
                } else if (item.itemClass === 'currency') {
                    Game.addMessage(`You see ${item.name} here!`, 'loot');
                } else {
                    Game.addMessage(`You see a ${item.name} here!`, 'loot');
                }
            });
        };

        Game.pickupItem = function() {
            const player = Game.player;
            const itemsHere = Game.items.filter(i => i.x === player.x && i.y === player.y);
            
            if (itemsHere.length === 0) {
                Game.addMessage("There's nothing here to pick up.", 'info');
                return;
            }
            
            const item = itemsHere[0];
            if (player.addToInventory(item)) {
                Game.items = Game.items.filter(i => i !== item);
                Game.addMessage(`You pick up the ${item.name}.`, 'action');
            }
        };

        Game.dropItem = function(item) {
            if (!item) {
                // Show drop menu if no item specified
                if (Game.player.inventory.length === 0) {
                    Game.addMessage("You have nothing to drop!", 'info');
                    return;
                }
                
                // Build menu items
                const menuItems = Game.player.inventory.map(invItem => {
                    let description = `Weight: ${invItem.weight || 1}`;
                    if (invItem.cursed) description += ' (cursed)';
                    if (invItem.equipped) description = 'Currently equipped';
                    
                    return {
                        name: invItem.name,
                        description: description,
                        disabled: invItem.equipped,  // Can't drop equipped items
                        data: invItem
                    };
                });
                
                Game.MenuSystem.show(
                    'DROP ITEM',
                    menuItems,
                    (selected) => {
                        Game.dropItem(selected.data);
                    },
                    'Choose an item to drop'
                );
                return;
            }
            
            // Check if item is equipped
            const equipped = Game.getAllEquippedItems();
            if (equipped.includes(item)) {
                Game.addMessage("You must unequip the item first!", 'warning');
                return;
            }
            
            // Check if item is cursed and stuck in inventory
            if (item.cursedStuck) {
                Game.addMessage(`The ${item.name} is cursed and stuck to you!`, 'danger');
                return;
            }
            
            // Remove from inventory
            if (!Game.player.removeFromInventory(item)) {
                Game.addMessage("You don't have that item!", 'warning');
                return;
            }
            
            // Place on ground at player's position
            item.x = Game.player.x;
            item.y = Game.player.y;
            delete item.letter;  // Remove inventory letter
            Game.items.push(item);
            
            Game.addMessage(`You drop the ${item.name}.`, 'info');
            Game.processTurn();
        };
        
        Game.dropMultiple = function() {
            if (Game.player.inventory.length === 0) {
                Game.addMessage("You have nothing to drop!", 'info');
                return;
            }
            
            Game.addMessage("Drop what? (* for all, # for amount)", 'info');
            // This could open a more complex menu for dropping multiple items
            // For now, just use the single drop menu
            Game.dropItem();
        };

        // Level persistence functions (stub implementations for now)
        Game.savedLevels = {};
        
        Game.saveCurrentLevel = function() {
            // Store the current level state
            Game.savedLevels[Game.currentLevel] = {
                dungeon: JSON.parse(JSON.stringify(Game.dungeon)),
                monsters: Game.monsters.map(m => ({...m})),
                items: Game.items.map(i => ({...i})),
                remembered: Game.remembered ? JSON.parse(JSON.stringify(Game.remembered)) : []
            };
        };
        
        Game.loadLevel = function(level) {
            if (!Game.savedLevels[level]) {
                return false;
            }
            
            const saved = Game.savedLevels[level];
            Game.dungeon = saved.dungeon;
            Game.monsters = saved.monsters;
            Game.items = saved.items;
            Game.remembered = saved.remembered;
            
            // Find stairs and position player there
            for (let y = 0; y < Game.dungeon.length; y++) {
                for (let x = 0; x < Game.dungeon[y].length; x++) {
                    if (level > Game.currentLevel && Game.dungeon[y][x] === '<') {
                        // Coming from above, place at up stairs
                        Game.player.x = x;
                        Game.player.y = y;
                        return true;
                    } else if (level < Game.currentLevel && Game.dungeon[y][x] === '>') {
                        // Coming from below, place at down stairs
                        Game.player.x = x;
                        Game.player.y = y;
                        return true;
                    }
                }
            }
            
            return true;
        };
        
        Game.maxLevelReached = 1;
        Game.nextLevel = function() {
            // Save current level before leaving
            Game.saveCurrentLevel();
            
            Game.currentLevel++;
            Game.addMessage(`You descend to level ${Game.currentLevel}...`, 'action');
            
            // Check if we've been here before
            if (!Game.loadLevel(Game.currentLevel)) {
                // Generate new level if first visit
                Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);
                
                // Track deepest level
                if (Game.currentLevel > Game.maxLevelReached) {
                    Game.maxLevelReached = Game.currentLevel;
                }
                
                // Spawn monsters for new level
                Game.monsters = [];
                const monsterBudget = 3 + Math.floor(Math.random() * 5) + Math.floor(Game.currentLevel / 5);
                for (let i = 0; i < monsterBudget; i++) {
                    const spawnedMonsters = Game.spawnMonster(Game.currentLevel, 1, 'dungeon');
                    if (spawnedMonsters) {
                        Game.monsters.push(...spawnedMonsters);
                    }
                }
                
                // Fresh FOV for new level
                Game.remembered = [];
            } else {
                Game.addMessage("You return to familiar territory.", 'info');
            }
            
            render();
        };

        Game.prevLevel = function() {
            if (Game.currentLevel <= 1) {
                Game.addMessage("You can't go up from here!", 'warning');
                return;
            }
            
            // Save current level
            Game.saveCurrentLevel();
            
            Game.currentLevel--;
            Game.addMessage(`You ascend to level ${Game.currentLevel}...`, 'action');
            
            // Load the previous level (it must exist since we came from there)
            if (!Game.loadLevel(Game.currentLevel)) {
                Game.addMessage("ERROR: Previous level not found!", 'danger');
                return;
            }
            
            render();
        };

        Game.attemptExit = function() {
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            
            const modal = document.getElementById('exit-modal');
            const message = document.getElementById('exit-message');
            
            if (hasStone) {
                message.innerHTML = `
                    <strong style="color: var(--gold-bright);">You possess the Philosopher's Stone!</strong><br><br>
                    Leaving now will complete your quest successfully.<br>
                    Your journey will end in VICTORY.<br><br>
                    Do you wish to leave the dungeon?
                `;
            } else {
                message.innerHTML = `
                    <strong style="color: var(--health-red);">You do not have the Philosopher's Stone!</strong><br><br>
                    Leaving now will end your quest in failure.<br>
                    Your journey will end in DEFEAT.<br><br>
                    Do you still wish to leave the dungeon?
                `;
            }
            
            modal.classList.add('active');
        };

        Game.confirmExit = function() {
            document.getElementById('exit-modal').classList.remove('active');
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            
            if (hasStone) {
                Game.victory();
            } else {
                Game.gameOver("You fled the dungeon without the Philosopher's Stone.");
            }
        };

        Game.cancelExit = function() {
            document.getElementById('exit-modal').classList.remove('active');
            Game.addMessage("You decide to continue your quest.", 'info');
        };

        Game.victory = function() {
            document.getElementById('victory-modal').classList.add('active');
            // Remove all other event handlers
            document.removeEventListener('keydown', Game.handleKeyPress);
        };

        Game.showScoreboard = function() {
            // Hide victory modal if showing
            document.getElementById('victory-modal').classList.remove('active');
            
            const modal = document.getElementById('scoreboard-modal');
            const result = document.getElementById('score-result');
            const content = document.getElementById('scoreboard-content');
            
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            result.innerHTML = hasStone ? 
                '<span style="color: var(--gold-bright);">QUEST COMPLETE - VICTORY!</span>' : 
                '<span style="color: var(--health-red);">QUEST FAILED</span>';
            
            // Calculate score
            const score = Game.calculateScore();
            
            content.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Journey Statistics</h3>
                        <div class="score-line">Turns Survived: <span>${Game.turn}</span></div>
                        <div class="score-line">Deepest Level: <span>${Game.maxLevelReached}</span></div>
                        <div class="score-line">Monsters Slain: <span>${Game.getMonstersKilled()}</span></div>
                        <div class="score-line">Items Collected: <span>${Game.player.inventory.length}</span></div>
                        <div class="score-line">Knowledge Used: <span>${Game.getQuestionsAnswered()}</span></div>
                    </div>
                    <div>
                        <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Final Attributes</h3>
                        <div class="score-line">Strength: <span>${Game.player.strength}</span></div>
                        <div class="score-line">Constitution: <span>${Game.player.constitution}</span></div>
                        <div class="score-line">Dexterity: <span>${Game.player.dexterity}</span></div>
                        <div class="score-line">Intelligence: <span>${Game.player.intelligence}</span></div>
                        <div class="score-line">Wisdom: <span>${Game.player.wisdom}</span></div>
                        <div class="score-line">Perception: <span>${Game.player.perception}</span></div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 30px;">
                    <h2 style="color: var(--gold-bright);">FINAL SCORE: ${score}</h2>
                </div>
            `;
            
            modal.classList.add('active');
        };

        Game.calculateScore = function() {
            let score = 0;
            score += Game.turn * 10;
            score += Game.maxLevelReached * 1000;
            score += Game.getMonstersKilled() * 100;
            if (Game.player.inventory.some(item => item.id === 'philosophers_stone')) {
                score += 50000; // Huge bonus for winning
            }
            return score;
        };

        Game.getMonstersKilled = function() {
            return Object.values(Game.extinctions).reduce((sum, count) => sum + count, 0);
        };

        Game.getQuestionsAnswered = function() {
            // This would need to be tracked, for now return estimate
            return Game.getMonstersKilled() * 3; // Rough estimate
        };

        Game.showHelp = function() {
            const modal = document.getElementById('help-modal');
            modal.classList.add('active');
        };

        Game.hideHelp = function() {
            const modal = document.getElementById('help-modal');
            modal.classList.remove('active');
        };

        Game.gameOver = function(message) {
            Game.addMessage("=== GAME OVER ===", 'danger');
            Game.addMessage(message, 'danger');
            document.removeEventListener('keydown', Game.handleKeyPress);
            
            // Show scoreboard after a delay
            setTimeout(() => {
                Game.showScoreboard();
            }, 2000);
        };

        // ===== INITIALIZATION =====
        Game.init = function() {
            // Setup welcome screen
            const nameInput = document.getElementById('player-name-input');
            const startBtn = document.getElementById('start-game-btn');
            
            nameInput.focus();
            
            // Handle Enter key on name input
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    Game.startGame();
                }
            });
            
            startBtn.addEventListener('click', Game.startGame);
        };

        Game.startGame = async function() {
            const nameInput = document.getElementById('player-name-input');
            const playerName = nameInput.value.trim() || 'Hero';
            
            // Hide welcome, show game
            document.getElementById('welcome-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            // Get display element
            Game.display = document.getElementById('game-display');
            
            // Load monster data
            await Game.loadMonsterData();
            
            // Load item data
            await Game.loadItemData();

            // Load corpse data
            await Game.loadCorpseData();

            // Load food data
            await Game.loadFoodData();

            // LOAD QUESTIONS:
            await Game.QuizEngine.loadAllQuestions();

            // Create player
            Game.player = new Player(playerName);
            
            // Generate first dungeon (without monsters)
            Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);

            // Now spawn monsters after dungeon exists
            Game.monsters = [];
            const monsterBudget = 3 + Math.floor(Math.random() * 5);
            for (let i = 0; i < monsterBudget; i++) {
                const spawnedMonsters = Game.spawnMonster(Game.currentLevel, 1, 'dungeon');
                if (spawnedMonsters) {
                    Game.monsters.push(...spawnedMonsters);
                }
            }
            
            // Setup input
            document.addEventListener('keydown', Game.handleKeyPress);
            
            // Initial messages
            Game.addMessage(`Welcome, ${playerName}, to the Philosopher's Quest!`, 'success');
            Game.addMessage("Knowledge is power. Every action requires learning.", 'info');
            Game.addMessage("Press ? for help.", 'info');
            
            // Initial render
            render();
        };

        // Keyboard handler for multiple choice
                document.addEventListener('keydown', function(e) {
                    if (!Game.QuizEngine.isActive || !document.getElementById('quiz-modal').classList.contains('active')) return;
                    
                    // Check if it's a multiple choice question
                    const buttons = document.querySelectorAll('.quiz-choice-button');
                    if (buttons.length > 0) {
                        // A-D keys for choices
                        const key = e.key.toUpperCase();
                        buttons.forEach(btn => {
                            if (btn.dataset.key === key) {
                                btn.click();
                                e.preventDefault();
                            }
                        });
                        
                        // Enter to submit if choice selected
                        if (e.key === 'Enter' && Game.QuizEngine.selectedChoice) {
                            Game.QuizEngine.submitMultipleChoice();
                            e.preventDefault();
                        }
                    }
                });

        // Quiz modal event handlers
        document.getElementById('quiz-submit').addEventListener('click', function() {
            const answer = document.getElementById('quiz-answer').value;
            if (answer && Game.QuizEngine.isActive) {
                Game.QuizEngine.handleAnswer(answer);
            }
        });

        document.getElementById('quiz-answer').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const answer = e.target.value;
                if (answer && Game.QuizEngine.isActive) {
                    Game.QuizEngine.handleAnswer(answer);
                }
            }
        });

        // Help modal close handler
        document.addEventListener('keydown', function(e) {
            if (document.getElementById('help-modal').classList.contains('active')) {
                if (e.key === 'Escape' || e.key === '?') {
                    Game.hideHelp();
                    e.preventDefault();
                }
            }
        });

        // Start when page loads
        window.addEventListener('load', Game.init);
    </script>
</body>
</html>