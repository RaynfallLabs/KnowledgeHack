<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Philosopher's Quest - Knowledge is Power</title>
    <style>
        /* ===== PHILOSOPHER'S QUEST STYLESHEET ===== */

        /* Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Fira+Code:wght@300;400;500;600&display=swap');

        /* CSS Variables */
        :root {
            /* Dark Academia Color Palette */
            --bg-void: #0a0a0f;
            --bg-dark: #12121a;
            --bg-panel: #1a1a28;
            --bg-raised: #242438;
            
            /* Accent Colors */
            --gold-bright: #ffd700;
            --gold-dim: #b8860b;
            --wisdom-purple: #9b59b6;
            --knowledge-blue: #3498db;
            --magic-cyan: #00ffff;
            
            /* Status Colors */
            --health-red: #e74c3c;
            --stamina-green: #27ae60;
            --mana-blue: #2980b9;
            --warning-orange: #f39c12;
            
            /* Text Colors */
            --text-primary: #e8e3d8;
            --text-secondary: #a09890;
            --text-dim: #605850;
            
            /* Borders */
            --border-color: #3a3654;
            --border-gold: #8b7355;
            --glow-color: rgba(255, 215, 0, 0.3);
        }

        /* Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', monospace;
            background: var(--bg-void);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            background-image: 
                radial-gradient(ellipse at top left, rgba(155, 89, 182, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(52, 152, 219, 0.1) 0%, transparent 50%);
        }

        /* Screens */
        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        .screen.active {
            display: flex;
        }

        /* Welcome Screen */
        #welcome-screen {
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
        }

        .welcome-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: var(--gold-bright);
            text-shadow: 0 0 30px var(--glow-color);
            margin-bottom: 10px;
            letter-spacing: 0.2em;
        }

        .game-subtitle {
            font-size: 18px;
            color: var(--wisdom-purple);
            margin-bottom: 40px;
            font-style: italic;
        }

        .welcome-form {
            margin: 30px 0;
        }

        #player-name-input {
            width: 300px;
            padding: 12px 20px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'Fira Code', monospace;
        }

        #player-name-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
        }

        #start-game-btn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 30px rgba(52, 152, 219, 0.3);
        }

        .welcome-info {
            margin-top: 40px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .welcome-info p {
            margin: 10px 0;
        }

        /* Game Screen */
        #game-screen {
            flex-direction: column;
        }

        #game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Game Display */
        #game-display {
            flex: 1;
            background: #000;
            font-family: 'Courier New', 'Fira Code', monospace;
            font-size: 16px;
            font-weight: bold;
            padding: 20px;
            overflow: hidden;
            white-space: pre;
            line-height: 1.0;
            letter-spacing: 0.02em;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* Message Log */
        #message-log {
            height: 250px;  /* Increased from 180px */
            background: var(--bg-dark);
            border-top: 2px solid var(--border-color);
            padding: 12px;
            overflow-y: auto;
            font-size: 13px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #message-log::-webkit-scrollbar {
            width: 8px;
        }

        #message-log::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #message-log::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .message {
            padding: 4px 8px;
            margin: 2px 0;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .message.info { 
            color: var(--knowledge-blue);
            border-left-color: var(--knowledge-blue);
        }

        .message.success { 
            color: var(--stamina-green);
            border-left-color: var(--stamina-green);
            text-shadow: 0 0 2px currentColor;
        }

        .message.warning { 
            color: var(--warning-orange);
            border-left-color: var(--warning-orange);
        }

        .message.danger { 
            color: var(--health-red);
            border-left-color: var(--health-red);
            font-weight: 600;
            text-shadow: 0 0 3px currentColor;
        }

        .message.action { 
            color: var(--wisdom-purple);
            border-left-color: var(--wisdom-purple);
        }

        .message.loot { 
            color: var(--gold-bright);
            border-left-color: var(--gold-bright);
            text-shadow: 0 0 3px var(--glow-color);
        }

        /* Sidebar */
        #sidebar {
            width: 340px;
            background: linear-gradient(180deg, var(--bg-dark) 0%, var(--bg-panel) 100%);
            padding: 15px;
            overflow-y: auto;
            box-shadow: inset 2px 0 5px rgba(0, 0, 0, 0.3);
        }

        #sidebar::-webkit-scrollbar {
            width: 8px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        /* Stat Groups */
        .stat-group {
            margin-bottom: 20px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .stat-group h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px var(--glow-color);
        }

        /* Stat Bars */
        .stat-bar {
            height: 24px;
            background: linear-gradient(180deg, var(--bg-dark), rgba(0,0,0,0.8));
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin: 8px 0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 11px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.2), transparent);
        }

        .hp-bar { 
            background: linear-gradient(90deg, #8b0000, var(--health-red), #ff6b6b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        .sp-bar { 
            background: linear-gradient(90deg, #1a5c2a, var(--stamina-green), #52c77a);
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
        }

        .mp-bar { 
            background: linear-gradient(90deg, #1a4c7a, var(--mana-blue), var(--knowledge-blue));
            box-shadow: 0 0 20px rgba(41, 128, 185, 0.5);
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 0 3px #000, 0 0 6px #000;
            color: var(--text-primary);
            z-index: 10;
            letter-spacing: 0.05em;
        }

        /* Attributes Display */
        .stat-group div {
            font-size: 13px;
            margin: 4px 0;
            color: var(--text-secondary);
        }

        .stat-group div span {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Status Effects */
        #status-effects span {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: var(--bg-dark);
            border: 1px solid currentColor;
            border-radius: 4px;
            font-size: 11px;
            text-transform: uppercase;
        }

        /* Inventory */
        .inventory-item {
            padding: 4px 8px;
            font-size: 12px;
            margin: 2px 0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .inventory-item:hover {
            background: var(--bg-dark);
            padding-left: 12px;
        }

        .inventory-item.equipped { 
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border-left: 3px solid var(--stamina-green);
        }

        .inventory-item.blessed { 
            color: var(--magic-cyan);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.cursed { 
            color: var(--health-red);
            text-shadow: 0 0 3px currentColor;
        }

        .inventory-item.unidentified { 
            color: var(--text-dim);
            font-style: italic;
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            padding: 12px;
            background: var(--bg-raised);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
        }

        .controls h4 {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .control-line {
            color: var(--text-secondary);
            margin: 4px 0;
            display: flex;
            align-items: center;
        }

        .control-line .key {
            color: var(--knowledge-blue);
            font-weight: 600;
            background: var(--bg-dark);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            border: 1px solid var(--border-color);
            min-width: 80px;
            text-align: center;
        }

        /* Quiz Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-raised) 100%);
            border: 2px solid var(--gold-dim);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 50px rgba(255, 215, 0, 0.2),
                0 10px 40px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .quiz-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-bright);
            font-size: 28px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 20px var(--glow-color);
        }

        #quiz-subject {
            color: var(--wisdom-purple);
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quiz-timer {
            font-size: 48px;
            font-weight: 600;
            color: var(--stamina-green);
            margin: 20px 0;
            text-shadow: 0 0 10px currentColor;
            font-variant-numeric: tabular-nums;
        }

        .quiz-timer.warning { 
            color: var(--warning-orange);
            animation: pulse 1s infinite;
        }

        .quiz-timer.danger { 
            color: var(--health-red);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .quiz-progress {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 10px;
        }

        .quiz-question {
            font-size: 18px;
            line-height: 1.6;
            margin: 25px 0;
            padding: 20px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .quiz-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin: 10px 0;
            transition: all 0.3s ease;
            font-family: 'Fira Code', monospace;
        }

        .quiz-input:focus {
            outline: none;
            border-color: var(--knowledge-blue);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .quiz-button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--wisdom-purple), var(--knowledge-blue));
            color: var(--text-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 5px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .quiz-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
        }

        .quiz-feedback {
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { 
                transform: translateX(-20px);
                opacity: 0;
            }
            to { 
                transform: translateX(0);
                opacity: 1;
            }
        }

        .quiz-feedback.correct {
            color: var(--stamina-green);
            background: rgba(39, 174, 96, 0.1);
            border: 2px solid var(--stamina-green);
            text-shadow: 0 0 10px currentColor;
        }

        .quiz-feedback.wrong {
            color: var(--health-red);
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid var(--health-red);
            text-shadow: 0 0 10px currentColor;
        }

         /* Help Modal Styles */
        .help-command {
            padding: 4px 0;
            color: var(--text-primary);
            font-size: 14px;
        }

        .help-command .key {
            display: inline-block;
            min-width: 100px;
            color: var(--knowledge-blue);
            font-weight: 600;
            background: var(--bg-dark);
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .score-line {
            padding: 4px 0;
            color: var(--text-secondary);
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .score-line span {
            color: var(--text-primary);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen" class="screen active">
        <div class="welcome-content">
            <h1 class="game-title">PHILOSOPHER'S QUEST</h1>
            <p class="game-subtitle">Knowledge is Literally Power</p>
            <div class="welcome-form">
                <input type="text" id="player-name-input" placeholder="Enter your name, seeker..." maxlength="20">
                <button id="start-game-btn">Begin Your Quest</button>
            </div>
            <div class="welcome-info">
                <p>Every action requires knowledge.</p>
                <p>Every swing of your sword demands mathematics.</p>
                <p>Every piece of armor requires geography.</p>
                <p>Learn or perish in the depths.</p>
            </div>
        </div>
    </div>

    <!-- Main Game Screen -->
    <div id="game-screen" class="screen">
        <div id="game-container">
            <div id="main-area">
                <div id="game-display"></div>
                <div id="message-log"></div>
            </div>
            <div id="sidebar">
                <!-- Player Stats -->
                <div class="stat-group">
                    <h3>VITALS</h3>
                    <div class="stat-bar">
                        <div class="stat-bar-fill hp-bar" id="hp-bar"></div>
                        <div class="stat-bar-text" id="hp-text">HP: 20/20</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill sp-bar" id="sp-bar"></div>
                        <div class="stat-bar-text" id="sp-text">SP: 100/100</div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill mp-bar" id="mp-bar"></div>
                        <div class="stat-bar-text" id="mp-text">MP: 10/10</div>
                    </div>
                </div>
                
                <!-- Attributes -->
                <div class="stat-group">
                    <h3>ATTRIBUTES</h3>
                    <div>STR: <span id="str">10</span> | CON: <span id="con">10</span></div>
                    <div>DEX: <span id="dex">10</span> | INT: <span id="int">10</span></div>
                    <div>WIS: <span id="wis">10</span> | PER: <span id="per">10</span></div>
                </div>
                
                <!-- Status -->
                <div class="stat-group">
                    <h3>STATUS</h3>
                    <div>AC: <span id="ac">10</span> | Level: <span id="dungeon-level">1</span></div>
                    <div>Sight: <span id="sight">5</span> | Timer: <span id="timer">10</span>s</div>
                    <div id="hunger-status"></div>
                    <div id="burden-status"></div>
                    <div id="status-effects"></div>
                </div>

                <!-- Equipment -->
                <div class="stat-group">
                    <h3>EQUIPMENT</h3>
                    <div id="equipment-list">
                        <div class="inventory-item">Nothing equipped</div>
                    </div>
                </div>

                <!-- Inventory -->
                <div class="stat-group">
                    <h3>INVENTORY (<span id="weight">0/50</span>)</h3>
                    <div id="inventory-list">
                        <div class="inventory-item">Empty</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="controls">
                    <h4>CONTROLS</h4>
                    <div class="control-line">Press <span class="key">?</span> for commands</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal" class="modal">
        <div class="modal-content">
            <div class="quiz-header">
                <div class="quiz-title" id="quiz-title">Knowledge Challenge</div>
                <div id="quiz-subject">Mathematics</div>
                <div class="quiz-timer" id="quiz-timer">30</div>
                <div class="quiz-progress" id="quiz-progress">Question 1 | Score: 0</div>
            </div>
            <div class="quiz-question" id="quiz-question">Question will appear here</div>
            <div id="quiz-input-area">
                <input type="text" class="quiz-input" id="quiz-answer" placeholder="Type your answer..." autocomplete="off">
                <button class="quiz-button" id="quiz-submit">Submit Answer</button>
            </div>
            <div class="quiz-feedback" id="quiz-feedback" style="display: none;"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="quiz-header">
                <div class="quiz-title">COMMAND REFERENCE</div>
                <div style="color: var(--text-secondary); font-size: 14px;">Press ESC or ? to close</div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Movement</h3>
                    <div class="help-command"><span class="key">Arrows/Numpad</span> Move/Attack</div>
                    <div class="help-command"><span class="key">5 / . / Space</span> Wait</div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Dungeon</h3>
                    <div class="help-command"><span class="key">&gt;</span> Descend stairs</div>
                    <div class="help-command"><span class="key">&lt;</span> Ascend stairs <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Items</h3>
                    <div class="help-command"><span class="key">, / g</span> Get item</div>
                    <div class="help-command"><span class="key">d</span> Drop item <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">i</span> Inventory <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">e</span> Equip item <span style="color: var(--text-dim);">(not yet)</span></div>
                </div>
                
                <div>
                    <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Food System</h3>
                    <div class="help-command"><span class="key">h</span> Harvest corpse <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">c</span> Cook ingredients <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Magic</h3>
                    <div class="help-command"><span class="key">r</span> Read scroll/book <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">q</span> Quaff potion <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">z</span> Zap wand <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">C</span> Cast spell <span style="color: var(--text-dim);">(not yet)</span></div>
                    
                    <h3 style="color: var(--gold-bright); margin: 15px 0 10px;">Special</h3>
                    <div class="help-command"><span class="key">I</span> Identify <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">p</span> Pray <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">l</span> Lockpick <span style="color: var(--text-dim);">(not yet)</span></div>
                    <div class="help-command"><span class="key">f</span> Fire ranged <span style="color: var(--text-dim);">(not yet)</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Exit Confirmation Modal -->
    <div id="exit-modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="quiz-header">
                <div class="quiz-title">LEAVE THE DUNGEON?</div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p id="exit-message" style="font-size: 16px; margin-bottom: 20px;"></p>
                <div style="margin-top: 30px;">
                    <button class="quiz-button" onclick="Game.confirmExit()">Yes, Leave</button>
                    <button class="quiz-button" onclick="Game.cancelExit()">No, Stay</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victory-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="quiz-header">
                <div class="quiz-title" style="color: var(--gold-bright); font-size: 36px; text-shadow: 0 0 30px var(--glow-color);">
                    VICTORY!
                </div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="font-size: 20px; color: var(--wisdom-purple); margin: 20px 0;">
                    You have retrieved the Philosopher's Stone!
                </p>
                <p style="font-size: 16px; color: var(--text-primary); margin: 20px 0;">
                    Knowledge truly is power. You have proven yourself worthy<br>
                    by mastering both wisdom and courage to complete your quest.
                </p>
                <div style="font-size: 24px; color: var(--gold-bright); margin: 30px 0; animation: pulse 2s infinite;">
                    ✦ ✦ ✦
                </div>
                <button class="quiz-button" onclick="Game.showScoreboard()">View Your Legacy</button>
            </div>
        </div>
    </div>

    <!-- Scoreboard Modal -->
    <div id="scoreboard-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="quiz-header">
                <div class="quiz-title">FINAL SCORE</div>
                <div id="score-result" style="font-size: 18px; margin-top: 10px;"></div>
            </div>
            <div id="scoreboard-content" style="padding: 20px;">
                <!-- Score details will be inserted here -->
            </div>
            <div style="text-align: center; padding: 20px;">
                <button class="quiz-button" onclick="location.reload()">New Game</button>
            </div>
        </div>
    </div>
    <script>
        // ===== PHILOSOPHER'S QUEST - COMPLETE GAME =====
        
        // Global game state
        const Game = {
            // Core state
            player: null,
            dungeon: null,
            monsters: [],
            items: [],
            currentLevel: 1,
            turn: 0,
            
            // Display
            display: null,
            messageLog: [],
            maxMessages: 100,
            
            // Quiz state
            activeQuiz: null,
            quizTimer: null,
            quizTimeRemaining: 0,
            
            // Game configuration
            config: {
                mapWidth: 80,
                mapHeight: 25,
                baseHP: 20,
                baseSP: 100,
                baseMP: 10,
                startingWisdom: 10
            }
        };

        // ===== DICE SYSTEM =====
        Game.Dice = {
            // Parse and roll dice notation: "2d6+3", "1d20", "3d4-2", etc.
            roll: function(notation) {
                if (!notation) return 0;
                
                // Handle plain numbers
                if (!isNaN(notation)) return parseInt(notation);
                
                // Parse dice notation with regex
                const match = notation.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
                if (!match) return parseInt(notation) || 0;
                
                const count = parseInt(match[1] || 1);
                const sides = parseInt(match[2]);
                const modifier = parseInt(match[3] || 0);
                
                let total = modifier;
                for (let i = 0; i < count; i++) {
                    total += Math.floor(Math.random() * sides) + 1;
                }
                
                return Math.max(0, total); // Never return negative
            },
            
            // Roll with advantage (roll twice, take higher)
            rollAdvantage: function(notation) {
                return Math.max(this.roll(notation), this.roll(notation));
            },
            
            // Roll with disadvantage (roll twice, take lower)
            rollDisadvantage: function(notation) {
                return Math.min(this.roll(notation), this.roll(notation));
            },
            
            // Roll multiple times and return array
            rollMultiple: function(notation, times) {
                const results = [];
                for (let i = 0; i < times; i++) {
                    results.push(this.roll(notation));
                }
                return results;
            },
            
            // Check if roll meets or exceeds target
            check: function(notation, target) {
                return this.roll(notation) >= target;
            },
            
            // Get average result for a dice notation (for balancing)
            average: function(notation) {
                const match = notation.match(/^(\d+)?d(\d+)([+-]\d+)?$/i);
                if (!match) return parseInt(notation) || 0;
                
                const count = parseInt(match[1] || 1);
                const sides = parseInt(match[2]);
                const modifier = parseInt(match[3] || 0);
                
                return (count * (sides + 1) / 2) + modifier;
            }
        };


        // ===== QUIZ ENGINE =====
        Game.QuizEngine = {
            currentQuiz: null,
            timer: null,
            timeRemaining: 0,
            isActive: false,
            questions: {},
            loaded: false,
            
            // Load all question banks at startup
            loadAllQuestions: async function() {
                if (this.loaded) return;
                
                const subjects = [
                    'math', 'philosophy', 'geography', 'science', 
                    'history', 'economics', 'cooking', 'grammar', 'animal'
                ];
                
                console.log('Loading question banks...');
                
                for (const subject of subjects) {
                    try {
                        const response = await fetch(`data/questions/questions-${subject}.json`);
                        if (!response.ok) {
                            console.warn(`✗ ${subject} questions not found`);
                            this.questions[subject] = this.createPlaceholderQuestions(subject);
                        } else {
                            const data = await response.json();
                            // Handle wrapped or unwrapped JSON structure
                            this.questions[subject] = data[subject] || data;
                            console.log(`✓ Loaded ${subject}`);
                        }
                    } catch (error) {
                        console.error(`Failed to load ${subject}:`, error);
                        this.questions[subject] = this.createPlaceholderQuestions(subject);
                    }
                }
                
                this.loaded = true;
                console.log('Question loading complete!');
            },
            
            // Create placeholder questions for missing files
            createPlaceholderQuestions: function(subject) {
                return {
                    "1": {
                        "tier": 1,
                        "questions": [
                            {"question": `Sample ${subject}: What is 2 + 2?`, "answer": "4", "type": "input"},
                            {"question": `Sample ${subject}: What is 5 × 3?`, "answer": "15", "type": "input"}
                        ]
                    }
                };
            },
            
            // Get a random question from subject and tier
            getRandomQuestion: function(subject, tier = 1) {
                const tierKey = tier.toString();
                
                if (!this.questions[subject]) {
                    console.error(`Subject ${subject} not loaded`);
                    return null;
                }
                
                if (!this.questions[subject][tierKey]) {
                    // Fallback to tier 1
                    if (this.questions[subject]["1"]) {
                        const questions = this.questions[subject]["1"].questions;
                        return questions[Math.floor(Math.random() * questions.length)];
                    }
                    return null;
                }
                
                const questions = this.questions[subject][tierKey].questions;
                return questions[Math.floor(Math.random() * questions.length)];
            },
            
            // Start a quiz with specified parameters
            startQuiz: function(params) {
                if (this.isActive) {
                    console.warn('Quiz already active');
                    return;
                }
                
                // Initialize quiz state
                this.currentQuiz = {
                    mode: params.mode,
                    subject: params.subject,
                    currentTier: params.startingTier || 1,
                    threshold: params.threshold || 0,
                    maxChain: params.maxChain || 0,
                    callback: params.callback,
                    reason: params.reason || 'quiz',
                    target: params.target || null,
                    
                    // Progress tracking
                    correctCount: 0,
                    totalAsked: 0,
                    currentQuestion: null,
                    questionHistory: []
                };
                
                this.isActive = true;
                
                // Show quiz start message
                const subjectName = params.subject.charAt(0).toUpperCase() + params.subject.slice(1);
                Game.addMessage(`${subjectName} challenge begins! (${this.getModeDescription(params.mode)})`, 'info');
                
                // Show first question
                this.showNextQuestion();
            },
            
            // Show the next question
            showNextQuestion: function() {
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                // Check if quiz should end
                if (this.shouldEndQuiz()) {
                    this.endQuiz(true);
                    return;
                }
                
                // Get next question
                const question = this.getRandomQuestion(quiz.subject, quiz.currentTier);
                if (!question) {
                    console.error(`No questions available for ${quiz.subject} tier ${quiz.currentTier}`);
                    this.endQuiz(false);
                    return;
                }
                
                quiz.currentQuestion = question;
                quiz.totalAsked++;
                
                // Calculate timer based on wisdom
                // Only set timer and start it on the FIRST question
                if (quiz.correctCount === 0 && quiz.totalAsked === 1) {
                    this.timeRemaining = Game.player.getQuizTimer();
                    this.startTimer();
                }

                // Show quiz modal
                this.showQuizModal(question);
                },

            // Display the quiz modal
            showQuizModal: function(question) {
                const modal = document.getElementById('quiz-modal');
                const quiz = this.currentQuiz;
                
                // Update modal content
                document.getElementById('quiz-title').textContent = quiz.reason || 'Knowledge Challenge';
                document.getElementById('quiz-subject').textContent = quiz.subject.toUpperCase();
                document.getElementById('quiz-question').textContent = question.question;
                document.getElementById('quiz-timer').textContent = this.timeRemaining;
                document.getElementById('quiz-progress').textContent = 
                    `Question ${quiz.totalAsked} | Score: ${quiz.correctCount}`;
                
                // Clear previous answer
                document.getElementById('quiz-answer').value = '';
                document.getElementById('quiz-feedback').style.display = 'none';
                
                // Show modal
                modal.classList.add('active');
                document.getElementById('quiz-answer').focus();
            },
            
            // Check if quiz should end
            shouldEndQuiz: function() {
                const quiz = this.currentQuiz;
                
                switch (quiz.mode) {
                    case 'threshold':
                    case 'escalator_threshold':
                        return quiz.correctCount >= quiz.threshold;
                    case 'chain':
                    case 'escalator_chain':
                        // Chain ends on first wrong answer, checked elsewhere
                        return quiz.correctCount >= quiz.maxChain;
                    default:
                        return false;
                }
            },
            
            // Handle answer submission
            handleAnswer: function(answer) {
                const quiz = this.currentQuiz;
                if (!quiz || !quiz.currentQuestion) return;
                
                // Normalize answers
                const normalizedAnswer = answer.toLowerCase().trim().replace(/[.,!?;]/g, '');
                const normalizedCorrect = (quiz.currentQuestion.answer || '').toLowerCase().trim().replace(/[.,!?;]/g, '');
                
                const correct = normalizedAnswer === normalizedCorrect;
                
                if (correct) {
                    quiz.correctCount++;
                    quiz.questionHistory.push({question: quiz.currentQuestion, correct: true});
                    
                    Game.addMessage('Correct!', 'success');
                    document.getElementById('quiz-answer').value = '';
                    
                    // Check if we should continue or end
                    if (quiz.mode === 'threshold' || quiz.mode === 'escalator_threshold') {
                        // Threshold: check if we've reached the required number
                        if (quiz.correctCount >= quiz.threshold) {
                            this.endQuiz(true);  // Success!
                        } else {
                            // Need more correct answers
                            if (quiz.mode === 'escalator_threshold' && quiz.currentTier < 5) {
                                quiz.currentTier++;
                            }
                            this.showNextQuestion();
                        }
                    } else if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                        // Chain: check if we've hit max chain
                        if (quiz.maxChain && quiz.correctCount >= quiz.maxChain) {
                            this.endQuiz(true);  // Max chain reached
                        } else {
                            // Continue chain
                            if (quiz.mode === 'escalator_chain' && quiz.currentTier < 5) {
                                quiz.currentTier++;
                            }
                            this.showNextQuestion();
                        }
                    }
                    
                } else {
                    // Wrong answer - quiz ALWAYS ends
                    quiz.questionHistory.push({
                        question: quiz.currentQuestion, 
                        correct: false,
                        userAnswer: answer
                    });
                    
                    Game.addMessage(`Wrong! The answer was: ${quiz.currentQuestion.answer}`, 'warning');
                    
                    // End quiz with current score
                    this.endQuiz(false);
                }
            },
            
            // End the quiz
            endQuiz: function(reachedGoal) {
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                this.stopTimer();
                
                // Build result
                const result = {
                    mode: quiz.mode,
                    subject: quiz.subject,
                    score: quiz.correctCount,
                    totalAsked: quiz.totalAsked,
                    success: false,
                    target: quiz.target
                };
                
                // Determine success based on mode
                if (quiz.mode === 'threshold' || quiz.mode === 'escalator_threshold') {
                    // Threshold modes: binary success only if reached threshold
                    result.success = quiz.correctCount >= quiz.threshold;
                } else if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                    // Chain modes: always "succeed" with the score you got
                    // Score 0 = complete failure, 1+ = incremental success
                    result.success = true;  // The callback will handle score-based outcomes
                }
                
                // Clear quiz state
                this.currentQuiz = null;
                this.isActive = false;
                
                // Hide modal
                document.getElementById('quiz-modal').classList.remove('active');
                
                // Call callback with result
                if (quiz.callback) {
                    quiz.callback(result);
                }
                
                // Show final message
                if (quiz.mode === 'chain' || quiz.mode === 'escalator_chain') {
                    Game.addMessage(`Quiz ended. Chain length: ${result.score}`, 'info');
                } else {
                    if (result.success) {
                        Game.addMessage(`Quiz passed! Got ${result.score} correct.`, 'success');
                    } else {
                        Game.addMessage(`Quiz failed. Got ${result.score} correct, needed ${quiz.threshold}.`, 'warning');
                    }
                }
            },
            
            // Timer functions
            startTimer: function() {
                this.stopTimer();
                
                this.timer = setInterval(() => {
                    this.timeRemaining--;
                    
                    const timerEl = document.getElementById('quiz-timer');
                    timerEl.textContent = this.timeRemaining;
                    
                    // Add warning colors
                    if (this.timeRemaining <= 5) {
                        timerEl.className = 'quiz-timer danger';
                    } else if (this.timeRemaining <= 10) {
                        timerEl.className = 'quiz-timer warning';
                    }
                    
                    if (this.timeRemaining <= 0) {
                        this.handleTimeout();
                    }
                }, 1000);
            },
            
            stopTimer: function() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            },
            
            handleTimeout: function() {
                this.stopTimer();
                const quiz = this.currentQuiz;
                if (!quiz) return;
                
                Game.addMessage("Time's up!", 'danger');
                
                quiz.questionHistory.push({
                    question: quiz.currentQuestion,
                    correct: false,
                    timeout: true
                });
                
                // Show correct answer
                const feedback = document.getElementById('quiz-feedback');
                feedback.textContent = `Time's up! The answer was: ${quiz.currentQuestion.answer}`;
                feedback.className = 'quiz-feedback wrong';
                feedback.style.display = 'block';
                
                setTimeout(() => this.endQuiz(false), 2000);
            },
            
            getModeDescription: function(mode) {
                switch (mode) {
                    case 'threshold': return 'Answer correctly to succeed';
                    case 'chain': return 'Build a chain of correct answers';
                    case 'escalator_threshold': return 'Questions get harder';
                    case 'escalator_chain': return 'Chain with increasing difficulty';
                    default: return 'Quiz';
                }
            }
        };

        // ===== PLAYER CLASS =====
        class Player {
            constructor(name = "Hero") {
                this.name = name;
                
                // Core attributes
                this.strength = 10;
                this.constitution = 10;
                this.dexterity = 10;
                this.intelligence = 10;
                this.wisdom = 10;
                this.perception = 10;
                
                // Derived stats
                this.maxHp = Game.config.baseHP + Math.floor((this.constitution - 10) / 2);
                this.hp = this.maxHp;
                this.maxSp = Game.config.baseSP + (this.constitution - 10) * 2;
                this.sp = this.maxSp;
                this.maxMp = Game.config.baseMP + Math.floor((this.intelligence - 10) / 2);
                this.mp = this.maxMp;
                
                // Position
                this.x = 0;
                this.y = 0;
                
                // Equipment slots
                this.equipped = {
                    weapon: null,
                    armor: {
                        head: null,
                        body: null,
                        hands: null,
                        legs: null,
                        cloak: null,
                        shirt: null
                    },
                    accessories: {
                        leftRing: null,
                        rightRing: null,
                        amulet: null
                    }
                };
                
                // Inventory
                this.inventory = [];
                this.maxCarry = 50 + this.strength * 2;
                this.currentWeight = 0;
                
                // Status flags
                this.statusFlags = {
                    isStarving: false,
                    isConfused: false,
                    isBlind: false,
                    isStunned: false,
                    isHallucinating: false,
                    isParalyzed: false,
                    isSick: false,
                    isPoisoned: false,
                    isStoned: false,
                    isSlimed: false,
                    isLevitating: false,
                    isFlying: false,
                    isInvisible: false
                };
                
                // Inventory letter assignment
                this.nextInventoryLetter = 'a';
            }
            
            getAC() {
                let ac = 10 + Math.floor((this.dexterity - 10) / 2);
                Object.values(this.equipped.armor).forEach(armor => {
                    if (armor) ac += armor.acBonus || 0;
                });
                return ac;
            }
            
            getSightRadius() {
                return 3 + Math.floor(this.perception / 5);
            }
            
            getQuizTimer() {
                return this.wisdom;
            }            
            getHungerStatus() {
                const percent = this.sp / this.maxSp;
                if (this.sp <= 0) return "Starving";
                if (percent <= 0.1) return "Fainting";
                if (percent <= 0.2) return "Weak";
                if (percent <= 0.3) return "Hungry";
                if (percent >= 1.2) return "Satiated";
                return "";
            }
            
            getBurdenStatus() {
                const percent = (this.currentWeight / this.maxCarry) * 100;
                if (percent > 300) return "Overloaded";
                if (percent > 200) return "Overtaxed";
                if (percent > 150) return "Strained";
                if (percent > 100) return "Stressed";
                if (percent > 75) return "Burdened";
                return "";
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    Game.gameOver("You have died!");
                }
            }
            
            spendSP(amount = 1) {
                this.sp -= amount;
                if (this.sp <= 0) {
                    this.sp = 0;
                    this.statusFlags.isStarving = true;
                    this.takeDamage(1);
                    Game.addMessage("You're starving! You take damage!", 'danger');
                } else {
                    this.statusFlags.isStarving = false;
                }
            }
            
            restoreSP(amount) {
                this.sp = Math.min(this.maxSp, this.sp + amount);
                if (this.sp > 0) this.statusFlags.isStarving = false;
            }
            
            addToInventory(item) {
                if (this.currentWeight + (item.weight || 1) > this.maxCarry) {
                    Game.addMessage("You can't carry that much weight!", 'warning');
                    return false;
                }
                
                // Assign inventory letter
                item.letter = this.nextInventoryLetter;
                this.nextInventoryLetter = String.fromCharCode(this.nextInventoryLetter.charCodeAt(0) + 1);
                if (this.nextInventoryLetter > 'z') this.nextInventoryLetter = 'A';
                
                this.inventory.push(item);
                this.currentWeight += item.weight || 1;
                return true;
            }
            
            removeFromInventory(item) {
                const index = this.inventory.indexOf(item);
                if (index > -1) {
                    this.inventory.splice(index, 1);
                    this.currentWeight -= item.weight || 1;
                    return true;
                }
                return false;
            }
        }
        
        // ===== FOV (FIELD OF VIEW) =====
        // Shadowcasting algorithm for proper line of sight
        Game.calculateFOV = function() {
            const fov = [];
            for (let y = 0; y < Game.config.mapHeight; y++) {
                fov[y] = [];
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    fov[y][x] = false;
                }
            }
            
            const px = Game.player.x;
            const py = Game.player.y;
            const radius = Game.player.getSightRadius();
            
            // Player can always see themselves
            if (py >= 0 && py < fov.length && px >= 0 && px < fov[0].length) {
                fov[py][px] = true;
            }
            
            // Cast light in 8 octants
            for (let octant = 0; octant < 8; octant++) {
                Game.castLight(fov, px, py, radius, 1, 1.0, 0.0, 
                    Game.multipliers[0][octant], Game.multipliers[1][octant],
                    Game.multipliers[2][octant], Game.multipliers[3][octant]);
            }
            
            return fov;
        };
        
        // Shadowcasting octant multipliers
        Game.multipliers = [
            [1, 0, 0, -1, -1, 0, 0, 1],
            [0, 1, -1, 0, 0, -1, 1, 0],
            [0, 1, 1, 0, 0, -1, -1, 0],
            [1, 0, 0, 1, -1, 0, 0, -1]
        ];
        
        Game.castLight = function(fov, cx, cy, radius, row, start, end, xx, xy, yx, yy) {
            if (start < end) return;
            
            const radius2 = radius * radius;
            
            for (let j = row; j <= radius; j++) {
                let dx = -j - 1;
                let dy = -j;
                let blocked = false;
                let newStart = start;
                
                while (dx <= 0) {
                    dx++;
                    
                    const X = cx + dx * xx + dy * xy;
                    const Y = cy + dx * yx + dy * yy;
                    
                    const lSlope = (dx - 0.5) / (dy + 0.5);
                    const rSlope = (dx + 0.5) / (dy - 0.5);
                    
                    if (newStart < rSlope) continue;
                    if (end > lSlope) break;
                    
                    if (dx * dx + dy * dy < radius2) {
                        if (Y >= 0 && Y < fov.length && X >= 0 && X < fov[0].length) {
                            fov[Y][X] = true;
                        }
                    }
                    
                    if (blocked) {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#') {
                            newStart = rSlope;
                            continue;
                        } else {
                            blocked = false;
                            start = newStart;
                        }
                    } else {
                        if (Y >= 0 && Y < Game.dungeon.length && 
                            X >= 0 && X < Game.dungeon[0].length && 
                            Game.dungeon[Y][X] === '#' && j < radius) {
                            blocked = true;
                            Game.castLight(fov, cx, cy, radius, j + 1, start, lSlope,
                                xx, xy, yx, yy);
                            newStart = rSlope;
                        }
                    }
                }
                
                if (blocked) break;
            }
        };

        // ===== MONSTER SYSTEM =====
        // Track extinctions globally
        Game.extinctions = {};
        Game.monsterData = { monsters: [] };

        // Load monster data from JSON file
        Game.loadMonsterData = async function() {
            try {
                const response = await fetch('data/monsters.json');
                Game.monsterData = await response.json();
                console.log(`Loaded ${Game.monsterData.monsters.length} monster types`);
            } catch (error) {
                console.error('Failed to load monsters.json:', error);
                // Fallback to basic monsters if file fails
                Game.monsterData = {
                    monsters: [
                        {id: "goblin", name: "goblin", symbol: "o", color: "#00FF00", mlevel: 1, speed: 12, hit_dice: "1d8", attacks: [{type: "weapon", adtyp: "phys", dam: "1d4"}], frequency: 6, geno_flags: ["geno"], environment_flags: ["dungeon"], extinction_cap: 120, pack_size: "1", ai_pattern: "aggressive", carries: {gold: true}, loot_system: "none"}
                    ]
                };
            }
        };

        // ===== ITEM SYSTEM =====
        // Item data storage - organized by class
        Game.itemData = {
            weapons: [],
            armor: [],
            accessories: [],
            ingredients: [],
            corpses: [],
            potions: [],
            scrolls: [],
            books: [],
            wands: [],
            tools: [],
            gems: [],
            currency: [],
            artifacts: []
        };

        // Load all item data files
        Game.loadItemData = async function() {
            const itemClasses = [
                'weapons', 'armor', 'accessories', 'ingredients', 'corpses',
                'potions', 'scrolls', 'books', 'wands', 'tools', 
                'gems', 'currency', 'artifacts'
            ];
            
            console.log('Loading item data files...');
            
            for (const itemClass of itemClasses) {
                try {
                    const response = await fetch(`data/objects/${itemClass}.json`);
                    if (!response.ok) {
                        console.warn(`✗ ${itemClass}.json not found, using defaults`);
                        Game.itemData[itemClass] = Game.getDefaultItems(itemClass);
                    } else {
                        const data = await response.json();
                        Game.itemData[itemClass] = data.items || data[itemClass] || [];
                        console.log(`✓ Loaded ${Game.itemData[itemClass].length} ${itemClass}`);
                    }
                } catch (error) {
                    console.error(`Failed to load ${itemClass}.json:`, error);
                    Game.itemData[itemClass] = Game.getDefaultItems(itemClass);
                }
            }
            
            console.log('Item loading complete!');
        };

        // Default items if files don't exist
        Game.getDefaultItems = function(itemClass) {
            const defaults = {
                weapons: [
                    {
                        id: "rusty_dagger",
                        name: "rusty dagger",
                        symbol: ")",
                        prob: 50,
                        weight: 2,
                        cost: 5,
                        min_depth: 1,
                        max_depth: 20,
                        rarity: "common",
                        quiz_tier: 1,
                        base_damage: 2,
                        chain_multipliers: [1, 1, 2, 2, 4],
                        max_chain_length: 5,
                        damage_types: ["pierce"]
                    }
                ],
                armor: [
                    {
                        id: "leather_cap",
                        name: "leather cap",
                        symbol: "[",
                        prob: 40,
                        weight: 2,
                        cost: 8,
                        min_depth: 1,
                        max_depth: 30,
                        rarity: "common",
                        slot: "head",
                        ac_bonus: 1,
                        equip_threshold: 2
                    }
                ],
                ingredients: [
                    {
                        id: "food_ration",
                        name: "food ration",
                        symbol: "%",
                        prob: 80,
                        weight: 1,
                        cost: 2,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        sp_restore: 30,
                        ingredient_type: "basic"
                    }
                ],
                corpses: [],
                potions: [
                    {
                        id: "healing_potion",
                        name: "potion of healing",
                        symbol: "!",
                        prob: 30,
                        weight: 1,
                        cost: 20,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        effect_type: "heal",
                        potency: "2d4+2",
                        quaff_threshold: 2
                    }
                ],
                scrolls: [
                    {
                        id: "identify_scroll",
                        name: "scroll of identify",
                        symbol: "?",
                        prob: 40,
                        weight: 1,
                        cost: 15,
                        min_depth: 1,
                        max_depth: 100,
                        rarity: "common",
                        effect_type: "identify",
                        read_threshold: 3
                    }
                ],
                currency: [
                    {
                        id: "gold_piece",
                        name: "gold piece",
                        symbol: "$",
                        weight: 0,
                        value: 1
                    }
                ]
            };
            
            return defaults[itemClass] || [];
        };

        // Get items by class
        Game.getItemsByClass = function(itemClass) {
            return Game.itemData[itemClass] || [];
        };

        // Item spawning functions
        Game.spawnFloorItems = function(rooms, depth) {
            const items = [];
            const floorClasses = ['weapons', 'armor', 'ingredients', 'potions', 'scrolls', 'gems', 'currency'];
            
            rooms.forEach(room => {
                if (Math.random() < 0.33) {
                    const itemClass = floorClasses[Math.floor(Math.random() * floorClasses.length)];
                    const classItems = Game.getItemsByClass(itemClass);
                    
                    const eligible = classItems.filter(item => 
                        item.min_depth <= depth && 
                        item.max_depth >= depth &&
                        item.rarity === "common"
                    );
                    
                    if (eligible.length === 0) return;
                    
                    const totalProb = eligible.reduce((sum, item) => sum + (item.prob || 10), 0);
                    let pick = Math.random() * totalProb;
                    let selected = null;
                    
                    for (const item of eligible) {
                        pick -= (item.prob || 10);
                        if (pick <= 0) {
                            selected = item;
                            break;
                        }
                    }
                    
                    if (selected) {
                        const x = room.x - 2 + Math.floor(Math.random() * 5);
                        const y = room.y - 2 + Math.floor(Math.random() * 5);
                        
                        items.push({
                            ...selected,
                            x: x,
                            y: y,
                            itemClass: itemClass,
                            identified: false,
                            blessed: Math.random() < 0.1,
                            cursed: Math.random() < (selected.curse_chance || 0.1),
                            enchantment: selected.can_enchant ? Math.floor(Math.random() * 3) - 1 : 0
                        });
                    }
                }
            });
            
            return items;
        };

        Game.dropMonsterLoot = function(monster) {
            const items = [];
            
            // Always drop corpse
            items.push({
                id: `${monster.id}_corpse`,
                name: `${monster.name} corpse`,
                itemClass: 'corpses',
                symbol: '%',
                weight: monster.weight || 10,
                x: monster.x,
                y: monster.y,
                harvest_tier: Math.ceil(monster.mlevel / 2),
                conferred: monster.conferred || []
            });
            
            // Check carries flags for additional loot
            if (monster.carries) {
                if (monster.carries.gold && Math.random() < 0.5) {
                    const goldAmount = Game.Dice.roll(`${monster.mlevel + 1}d10`);
                    items.push({
                        id: 'gold_pieces',
                        name: `${goldAmount} gold pieces`,
                        itemClass: 'currency',
                        symbol: '$',
                        weight: 0,
                        value: goldAmount,
                        x: monster.x,
                        y: monster.y
                    });
                }
                
                if (monster.carries.weapon && Math.random() < 0.3) {
                    const weapons = Game.getItemsByClass('weapons').filter(item => 
                        item.min_depth <= monster.mlevel &&
                        item.rarity === "common"
                    );
                    
                    if (weapons.length > 0) {
                        const weapon = weapons[Math.floor(Math.random() * weapons.length)];
                        items.push({
                            ...weapon,
                            itemClass: 'weapons',
                            x: monster.x,
                            y: monster.y,
                            identified: false,
                            cursed: Math.random() < 0.2
                        });
                    }
                }
            }
            
            return items;
        };
        // ===== MONSTER CLASS =====
        class Monster {
            constructor(monsterDef, x, y) {
                // Copy all definition fields
                Object.assign(this, monsterDef);
                
                // Instance-specific data
                this.x = x;
                this.y = y;
                this.maxHp = Game.Dice.roll(this.hit_dice || "1d8");
                this.hp = this.maxHp;
                this.dead = false;
                this.paralyzeTurns = 0;
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                }
            }
            
            move() {
                if (this.dead) return;
                if (this.paralyzeTurns > 0) {
                    this.paralyzeTurns--;
                    return;
                }
                
                // Speed check
                const speedRoll = Math.random() * 12;
                if (speedRoll > (this.speed || 12)) return;
                
                // AI patterns
                const pattern = this.ai_pattern || 'aggressive';
                switch(pattern) {
                    case 'aggressive':
                        this.moveAggressive();
                        break;
                    case 'cowardly':
                        this.moveCowardly();
                        break;
                    case 'grid':
                        this.moveGrid();
                        break;
                    case 'sessile':
                        break;
                    case 'slow':
                    case 'slow_pursuit':
                        if (Game.turn % 2 === 0) this.moveAggressive();
                        break;
                    default:
                        this.moveAggressive();
                }
            }
            
            moveAggressive() {
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                if (distance > 10) return;
                
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    moveY = dy > 0 ? 1 : -1;
                }
                
                this.tryMove(this.x + moveX, this.y + moveY);
            }
            
            moveCowardly() {
                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                if (distance < 3) {
                    const moveX = dx > 0 ? -1 : (dx < 0 ? 1 : 0);
                    const moveY = dy > 0 ? -1 : (dy < 0 ? 1 : 0);
                    this.tryMove(this.x + moveX, this.y + moveY);
                }
            }
            
            moveGrid() {
                // Grid bugs only move orthogonally
                const moves = [[0,1], [0,-1], [1,0], [-1,0]];
                const validMoves = moves.filter(([dx, dy]) => {
                    const newX = this.x + dx;
                    const newY = this.y + dy;
                    return Game.canMoveTo(newX, newY) && !Game.getMonsterAt(newX, newY);
                });
                
                if (validMoves.length > 0) {
                    const [dx, dy] = validMoves[Math.floor(Math.random() * validMoves.length)];
                    this.tryMove(this.x + dx, this.y + dy);
                }
            }
            
            tryMove(newX, newY) {
                if (newX === Game.player.x && newY === Game.player.y) {
                    this.attack();
                } else if (Game.canMoveTo(newX, newY) && !Game.getMonsterAt(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                }
            }
            
            attack() {
                if (!this.attacks || this.attacks.length === 0) return;
                
                let totalDamage = 0;
                for (const attack of this.attacks) {
                    totalDamage += Game.Dice.roll(attack.dam || "1d2");
                }
                
                if (totalDamage > 0) {
                    Game.player.takeDamage(totalDamage);
                    Game.addMessage(`The ${this.name} hits you for ${totalDamage} damage!`, 'danger');
                }
            }
        }

        // ===== MONSTER SPAWNING (NetHack-style) =====
        Game.spawnMonster = function(currentLevel, playerLevel = 1, levelType = 'dungeon') {
            // NetHack's zlevel calculation
            const zlevel = Math.max(currentLevel, Math.floor(playerLevel / 2)) + Math.floor(Math.random() * 3);
            
            // Filter eligible monsters
            const eligible = Game.monsterData.monsters.filter(m => {
                if ((m.mlevel || 0) > zlevel + 2) return false;
                if (m.environment_flags && !m.environment_flags.includes(levelType)) return false;
                const extinctCount = Game.extinctions[m.id] || 0;
                if (extinctCount >= (m.extinction_cap || 120)) return false;
                if (m.geno_flags && !m.geno_flags.includes('geno')) return false;
                return true;
            });
            
            if (eligible.length === 0) return null;
            
            // Weighted selection
            const totalFreq = eligible.reduce((sum, m) => sum + (m.frequency || 1), 0);
            let pick = Math.random() * totalFreq;
            let selected = null;
            
            for (const m of eligible) {
                pick -= (m.frequency || 1);
                if (pick <= 0) {
                    selected = m;
                    break;
                }
            }
            
            if (!selected) return null;
            
            // Track extinction
            Game.extinctions[selected.id] = (Game.extinctions[selected.id] || 0) + 1;
            
            // Find spawn location
            const pos = Game.findSpawnLocation();
            if (!pos) return null;
            
            // Handle pack spawning
            const packSize = Game.Dice.roll(selected.pack_size || "1");
            const monsters = [];
            
            for (let i = 0; i < packSize; i++) {
                const spawnPos = i === 0 ? pos : Game.findNearbySpawnLocation(pos.x, pos.y);
                if (spawnPos) {
                    monsters.push(new Monster(selected, spawnPos.x, spawnPos.y));
                }
            }
            
            return monsters;
        };
        
        Game.findSpawnLocation = function() {
            for (let attempts = 0; attempts < 100; attempts++) {
                const x = Math.floor(Math.random() * Game.config.mapWidth);
                const y = Math.floor(Math.random() * Game.config.mapHeight);
                
                // Check bounds first, THEN access the array
                if (y >= 0 && y < Game.config.mapHeight && 
                    x >= 0 && x < Game.config.mapWidth &&
                    Game.dungeon[y] && Game.dungeon[y][x] === '.' &&
                    !Game.getMonsterAt(x, y) && 
                    !(x === Game.player.x && y === Game.player.y)) {
                    const dist = Math.abs(x - Game.player.x) + Math.abs(y - Game.player.y);
                    if (dist > 10) return { x, y };
                }
            }
            return null;
        };
        
        Game.findNearbySpawnLocation = function(centerX, centerY) {
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (Game.dungeon[y] && Game.dungeon[y][x] === '.' &&
                        !Game.getMonsterAt(x, y) && 
                        !(x === Game.player.x && y === Game.player.y)) {
                        return { x, y };
                    }
                }
            }
            return null;
        };

        // ===== DUNGEON GENERATION =====
        function generateDungeon(width, height) {
            const dungeon = [];
            
            // Initialize with walls
            for (let y = 0; y < height; y++) {
                dungeon[y] = [];
                for (let x = 0; x < width; x++) {
                    dungeon[y][x] = '#';
                }
            }
            
            // Generate rooms
            const rooms = [];
            const numRooms = 5 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < numRooms; i++) {
                const roomWidth = 5 + Math.floor(Math.random() * 10);
                const roomHeight = 5 + Math.floor(Math.random() * 6);
                const roomX = 1 + Math.floor(Math.random() * (width - roomWidth - 2));
                const roomY = 1 + Math.floor(Math.random() * (height - roomHeight - 2));
                
                // Carve room
                for (let y = roomY; y < roomY + roomHeight; y++) {
                    for (let x = roomX; x < roomX + roomWidth; x++) {
                        dungeon[y][x] = '.';
                    }
                }
                
                rooms.push({
                    x: roomX + Math.floor(roomWidth / 2),
                    y: roomY + Math.floor(roomHeight / 2),
                    width: roomWidth,
                    height: roomHeight
                });
            }
            
            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                
                // Horizontal then vertical
                const startX = Math.min(room1.x, room2.x);
                const endX = Math.max(room1.x, room2.x);
                for (let x = startX; x <= endX; x++) {
                    dungeon[room1.y][x] = '.';
                }
                
                const startY = Math.min(room1.y, room2.y);
                const endY = Math.max(room1.y, room2.y);
                for (let y = startY; y <= endY; y++) {
                    dungeon[y][room2.x] = '.';
                }
            }
            
            // Place player in first room
            if (rooms.length > 0) {
                // Always place up stairs at spawn on level 1
                if (Game.currentLevel === 1) {
                    dungeon[rooms[0].y][rooms[0].x] = '<';
                }
                Game.player.x = rooms[0].x;
                Game.player.y = rooms[0].y;
            }

            // Place stairs in last room
            if (rooms.length > 1) {
                const lastRoom = rooms[rooms.length - 1];
                dungeon[lastRoom.y][lastRoom.x] = '>';
            }
            
            if (Game.currentLevel > 1 && rooms.length > 0) {
                dungeon[rooms[0].y][rooms[0].x] = '<';
            }
            // Spawn items using new system
            Game.items = Game.spawnFloorItems(rooms, Game.currentLevel);
            
            return dungeon;
        }

        // ===== RENDERING =====
        function render() {
            if (!Game.display || !Game.dungeon || !Game.player) return;
            
            // Calculate field of view
            const fov = Game.calculateFOV();
            
            // Build display with HTML for colors
            let displayHTML = '';
            
            for (let y = 0; y < Game.config.mapHeight; y++) {
                for (let x = 0; x < Game.config.mapWidth; x++) {
                    let char = ' ';
                    let color = '#222'; // Dark gray for unseen
                    
                    // Only render if in FOV
                    if (!fov[y] || !fov[y][x]) {
                        // Show remembered walls in dark gray
                        if (Game.remembered && Game.remembered[y] && Game.remembered[y][x] === '#') {
                            char = '#';
                            color = '#333';
                        } else {
                            char = ' ';
                        }
                    } else {
                        // Remember terrain
                        if (!Game.remembered) Game.remembered = [];
                        if (!Game.remembered[y]) Game.remembered[y] = [];
                        if (Game.dungeon[y] && Game.dungeon[y][x]) {
                            Game.remembered[y][x] = Game.dungeon[y][x];
                        }
                        
                        // Player
                        if (x === Game.player.x && y === Game.player.y) {
                            char = '@';
                            color = '#fff'; // White for player
                        }
                        // Monsters
                        else {
                            let hasMonster = false;
                            for (const monster of Game.monsters) {
                                if (!monster.dead && monster.x === x && monster.y === y) {
                                    char = monster.symbol;
                                    color = monster.color;
                                    hasMonster = true;
                                    break;
                                }
                            }
                            
                            if (!hasMonster) {
                                // Items
                                let hasItem = false;
                                for (const item of Game.items) {
                                    if (item.x === x && item.y === y) {
                                        char = item.symbol;
                                        // Item colors
                                        switch(item.type) {
                                            case 'food':
                                            case 'corpse':
                                                color = '#8b4513'; // Brown
                                                break;
                                            case 'weapon':
                                                color = '#c0c0c0'; // Silver
                                                break;
                                            case 'armor':
                                                color = '#4682b4'; // Steel blue
                                                break;
                                            case 'potion':
                                                color = '#ff1493'; // Deep pink
                                                break;
                                            default:
                                                color = '#ffd700'; // Gold
                                        }
                                        hasItem = true;
                                        break;
                                    }
                                }
                                
                                if (!hasItem) {
                                    // Terrain
                                    if (Game.dungeon[y] && Game.dungeon[y][x]) {
                                        char = Game.dungeon[y][x];
                                        // Terrain colors
                                        switch(char) {
                                            case '#':
                                                color = '#888'; // Light gray walls
                                                break;
                                            case '.':
                                                color = '#666'; // Dark gray floor
                                                break;
                                            case '>':
                                                color = '#ff0'; // Yellow stairs
                                                break;
                                            case '+':
                                                color = '#8b4513'; // Brown door
                                                break;
                                            default:
                                                color = '#666';
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    displayHTML += `<span style="color:${color}">${char}</span>`;
                }
                displayHTML += '\n';
            }
            
            Game.display.innerHTML = displayHTML;
            updateUI();
        }

        // ===== UI UPDATES =====
        function updateUI() {
            const player = Game.player;
            if (!player) return;
            
            // Update bars
            document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('hp-text').textContent = `HP: ${player.hp}/${player.maxHp}`;
            
            document.getElementById('sp-bar').style.width = (player.sp / player.maxSp * 100) + '%';
            document.getElementById('sp-text').textContent = `SP: ${player.sp}/${player.maxSp}`;
            
            document.getElementById('mp-bar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mp-text').textContent = `MP: ${player.mp}/${player.maxMp}`;
            
            // Update attributes
            document.getElementById('str').textContent = player.strength;
            document.getElementById('con').textContent = player.constitution;
            document.getElementById('dex').textContent = player.dexterity;
            document.getElementById('int').textContent = player.intelligence;
            document.getElementById('wis').textContent = player.wisdom;
            document.getElementById('per').textContent = player.perception;
            
            // Update status
            document.getElementById('ac').textContent = player.getAC();
            document.getElementById('sight').textContent = player.getSightRadius();
            document.getElementById('timer').textContent = player.getQuizTimer();
            document.getElementById('dungeon-level').textContent = Game.currentLevel;
            
            // Hunger status
            const hungerStatus = player.getHungerStatus();
            document.getElementById('hunger-status').textContent = hungerStatus;
            
            // Burden status
            const burdenStatus = player.getBurdenStatus();
            document.getElementById('burden-status').textContent = burdenStatus;
            
            // Weight
            document.getElementById('weight').textContent = `${player.currentWeight}/${player.maxCarry}`;
            
            // Inventory
            const invList = document.getElementById('inventory-list');
            if (player.inventory.length === 0) {
                invList.innerHTML = '<div class="inventory-item">Empty</div>';
            } else {
                invList.innerHTML = player.inventory.map(item => 
                    `<div class="inventory-item">${item.letter}) ${item.name}${item.identified ? '' : ' (?)'}</div>`
                ).join('');
            }
        }

        // ===== MESSAGE LOG =====
        Game.addMessage = function(text, type = 'info') {
            const messageLog = document.getElementById('message-log');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            
            messageLog.appendChild(message);
            messageLog.scrollTop = messageLog.scrollHeight;
            
            // Limit messages
            while (messageLog.children.length > Game.maxMessages) {
                messageLog.removeChild(messageLog.firstChild);
            }
        };

        // ===== INPUT HANDLING =====
        Game.handleKeyPress = function(e) {
            // Don't handle input during quiz
            if (Game.QuizEngine.isActive || document.getElementById('quiz-modal').classList.contains('active')) return;
            
            let dx = 0, dy = 0;
            
            // Movement keys
            switch(e.key) {
                // Arrow key movement
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                
                // Numpad diagonal movement
                case '7': dx = -1; dy = -1; break;  // NW
                case '8': dy = -1; break;           // N
                case '9': dx = 1; dy = -1; break;   // NE
                case '4': dx = -1; break;           // W
                case '6': dx = 1; break;            // E
                case '1': dx = -1; dy = 1; break;   // SW
                case '2': dy = 1; break;            // S
                case '3': dx = 1; dy = 1; break;    // SE
                
                // Wait
                case '5':
                case '.':
                case ' ':
                    Game.addMessage("You wait.", 'info');
                    Game.player.spendSP(1);
                    Game.processTurn();
                    return;
                
                // Item management
                case ',':
                case 'g':
                    Game.pickupItem();
                    Game.processTurn();
                    return;
                case 'd':
                    Game.addMessage("There is no drop command, only Zuul.", 'warning');
                    return;
                case 'i':
                    Game.addMessage("There is no inventory command, only Zuul.", 'warning');
                    return;
                
                // Equipment & Combat
                case 'e':
                    Game.addMessage("There is no equip command, only Zuul.", 'warning');
                    return;
                case 'f':
                    Game.addMessage("There is no fire command, only Zuul.", 'warning');
                    return;
                
                // Food system
                case 'h':
                    Game.addMessage("There is no harvest command, only Zuul.", 'warning');
                    return;
                case 'c':
                    Game.addMessage("There is no cook command, only Zuul.", 'warning');
                    return;
                
                // Magic items
                case 'r':
                    Game.addMessage("There is no read command, only Zuul.", 'warning');
                    return;
                case 'q':
                    Game.addMessage("There is no quaff command, only Zuul.", 'warning');
                    return;
                case 'z':
                    Game.addMessage("There is no zap command, only Zuul.", 'warning');
                    return;
                case 'C':
                    Game.addMessage("There is no cast command, only Zuul.", 'warning');
                    return;
                
                // Special actions
                case 'I':
                    Game.addMessage("There is no identify command, only Zuul.", 'warning');
                    return;
                case 'p':
                    Game.addMessage("There is no pray command, only Zuul.", 'warning');
                    return;
                case 'l':
                    Game.addMessage("There is no lockpick command, only Zuul.", 'warning');
                    return;
                
                // Stairs
                case '>':
                    if (Game.dungeon[Game.player.y][Game.player.x] === '>') {
                        Game.nextLevel();
                    } else {
                        Game.addMessage("There are no stairs here.", 'warning');
                    }
                    return;
                case '<':
                    if (Game.dungeon[Game.player.y][Game.player.x] === '<') {
                        if (Game.currentLevel === 1) {
                            Game.attemptExit();
                        } else {
                            Game.prevLevel();
                        }
                    } else {
                        Game.addMessage("There are no up stairs here.", 'warning');
                    }
                    return;
            }
            
            // Process movement
            if (dx !== 0 || dy !== 0) {
                Game.movePlayer(dx, dy);
                e.preventDefault();
            }
        };

        Game.movePlayer = function(dx, dy) {
            const player = Game.player;
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Check for monster
            const monster = Game.getMonsterAt(newX, newY);
            if (monster && !monster.dead) {
                Game.playerAttack(monster);
                return;
            }
            
            // Check if can move
            if (!Game.canMoveTo(newX, newY)) {
                Game.addMessage("You can't move there!", 'warning');
                return;
            }
            
            // Move player
            player.x = newX;
            player.y = newY;
            player.spendSP(1);
            
            // Check for items at new position
            const itemsHere = Game.items.filter(i => i.x === player.x && i.y === player.y);
            if (itemsHere.length > 0) {
                if (itemsHere.length === 1) {
                    Game.addMessage(`You see a ${itemsHere[0].name} here.`, 'info');
                } else {
                    Game.addMessage(`You see several items here.`, 'info');
                }
            }

            // Check for stairs
            if (Game.dungeon[newY][newX] === '>') {
                Game.addMessage("You see stairs leading down. Press > to descend.", 'info');
            }
            
            Game.processTurn();
        };

        Game.canMoveTo = function(x, y) {
            if (y < 0 || y >= Game.dungeon.length) return false;
            if (x < 0 || x >= Game.dungeon[y].length) return false;
            return Game.dungeon[y][x] !== '#';
        };

        Game.getMonsterAt = function(x, y) {
            return Game.monsters.find(m => !m.dead && m.x === x && m.y === y);
        };

        Game.processTurn = function() {
            // Move monsters
            Game.monsters.forEach(m => m.move());
            
            // Increment turn
            Game.turn++;
            
            // Render
            render();
        };

        Game.playerAttack = function(monster) {
            const weapon = Game.player.equipped.weapon || {
                // Default unarmed stats
                quiz_tier: 1,
                max_chain_length: 5,
                base_damage: 1,
                chain_multipliers: [1, 1.5, 2, 2.5, 3]
            };
            
            Game.QuizEngine.startQuiz({
                mode: 'chain',
                subject: 'math',
                startingTier: weapon.quiz_tier || 1,
                maxChain: weapon.max_chain_length || 5,
                reason: `Attacking ${monster.name}`,
                target: monster,
                callback: function(result) {
                    if (result.score > 0) {
                        // Use chain_multipliers if available, otherwise basic calculation
                        const multiplier = weapon.chain_multipliers ? 
                            (weapon.chain_multipliers[result.score - 1] || weapon.chain_multipliers[weapon.chain_multipliers.length - 1]) : 
                            result.score;
                        const damage = Math.floor(weapon.base_damage * multiplier);
                        
                        monster.takeDamage(damage);
                        Game.addMessage(`You hit the ${monster.name} for ${damage} damage!`, 'success');
                        
                        if (monster.dead) {
                            Game.addMessage(`The ${monster.name} dies!`, 'success');
                            Game.dropCorpse(monster);
                        }
                    } else {
                        Game.addMessage(`You miss the ${monster.name}!`, 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // FIRE - Ranged attack
        Game.playerFire = function() {
            // TODO: Implement targeting system
            Game.addMessage("Ranged weapons not yet implemented!", 'warning');
            return;
            
            /* Future implementation:
            const weapon = Game.player.equipped.weapon;
            if (!weapon || weapon.type !== 'ranged') {
                Game.addMessage("You need a ranged weapon equipped!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'chain',
                subject: 'math',  // or 'physics' for advanced weapons
                startingTier: weapon.quiz_tier || 1,
                maxChain: weapon.max_chain_length || 5,
                reason: 'Firing ' + weapon.name,
                callback: function(result) {
                    // Handle ranged damage
                }
            });
            */
        };

        // EQUIP - Put on armor or accessories
        Game.playerEquip = function(item) {
            if (!item) {
                Game.addMessage("What do you want to equip?", 'info');
                return;
            }
            
            // Determine quiz subject based on item type
            let subject = 'geography';  // default for armor
            if (item.class === 'ring' || item.class === 'amulet') {
                subject = 'history';  // accessories use history
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: subject,
                startingTier: item.quiz_tier || 1,
                threshold: item.equip_threshold || 3,
                reason: `Equipping ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Actually equip the item
                        Game.addMessage(`You equip the ${item.name}.`, 'success');
                    } else {
                        Game.addMessage(`You fail to equip the ${item.name}.`, 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // HARVEST - Convert corpse to raw food
        Game.playerHarvest = function(corpse) {
            if (!corpse || corpse.type !== 'corpse') {
                Game.addMessage("That's not a corpse!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'animal',
                startingTier: corpse.harvest_tier || 1,
                threshold: corpse.harvest_threshold || Game.Dice.roll('2d4'),  // 2-8 random
                reason: `Harvesting ${corpse.name}`,
                target: corpse,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Generate raw food items
                        Game.addMessage(`You successfully harvest the ${corpse.name}.`, 'success');
                    } else {
                        Game.addMessage(`You fail to harvest anything useful.`, 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // COOK - Create meals from ingredients
        Game.playerCook = function(ingredients) {
            if (!ingredients || ingredients.length === 0) {
                Game.addMessage("You need ingredients to cook!", 'warning');
                return;
            }
            
            // TODO: Determine tier based on ingredients
            const cookingTier = 1;
            
            Game.QuizEngine.startQuiz({
                mode: 'escalator_chain',
                subject: 'cooking',
                startingTier: cookingTier,
                maxChain: 5,  // 5 quality levels
                reason: 'Cooking a meal',
                target: ingredients,
                callback: function(result) {
                    const quality = result.score;
                    if (quality === 0) {
                        Game.addMessage("You ruin the food!", 'danger');
                    } else {
                        // TODO: Create food with stats based on quality
                        const qualityNames = ['', 'crude', 'decent', 'fine', 'excellent', 'masterwork'];
                        Game.addMessage(`You create a ${qualityNames[quality]} meal!`, 'success');
                        // Auto-consume and apply stats
                    }
                    Game.processTurn();
                }
            });
        };

        // CAST - Cast spell from memory
        Game.playerCast = function(spell) {
            if (!spell) {
                Game.addMessage("You don't know any spells!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: spell.quiz_mode || 'chain',
                subject: 'science',
                startingTier: spell.tier || 1,
                threshold: spell.threshold,
                maxChain: spell.max_chain,
                reason: `Casting ${spell.name}`,
                target: spell,
                callback: function(result) {
                    if (result.success || result.score > 0) {
                        // TODO: Apply spell effects
                        Game.addMessage(`You cast ${spell.name}!`, 'success');
                    } else {
                        Game.addMessage("The spell fizzles!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // READ - Read scroll or book
        Game.playerRead = function(item) {
            if (!item || (item.type !== 'scroll' && item.type !== 'book')) {
                Game.addMessage("That's not readable!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'grammar',
                startingTier: item.quiz_tier || 1,
                threshold: item.read_threshold || 3,
                reason: `Reading ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Trigger scroll effect or learn spell
                        Game.addMessage(`You successfully read the ${item.name}!`, 'success');
                    } else {
                        Game.addMessage("You can't comprehend the text!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // ZAP - Use wand or staff
        Game.playerZap = function(item) {
            if (!item || (item.type !== 'wand' && item.type !== 'staff')) {
                Game.addMessage("That's not a wand or staff!", 'warning');
                return;
            }
            
            if ((item.charges || 0) <= 0) {
                Game.addMessage("It has no charges left!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'science',  // or 'math' for some wands
                startingTier: item.quiz_tier || 1,
                threshold: item.zap_threshold || 2,
                reason: `Zapping ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Apply wand effect
                        item.charges--;
                        Game.addMessage(`You zap the ${item.name}! (${item.charges} charges left)`, 'success');
                    } else {
                        Game.addMessage("Nothing happens!", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // IDENTIFY - Reveal item properties (requires Philosopher's Amulet)
        Game.playerIdentify = function(item) {
            const hasAmulet = Game.player.equipped.accessories?.amulet?.id === 'philosophers_amulet';
            if (!hasAmulet) {
                Game.addMessage("You need the Philosopher's Amulet to identify items!", 'warning');
                return;
            }
            
            if (!item || item.identified) {
                Game.addMessage("That doesn't need identification!", 'info');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'philosophy',
                startingTier: item.quiz_tier || 1,
                threshold: item.identify_threshold || Game.Dice.roll('1d3+2'),  // 3-5
                reason: `Identifying ${item.name}`,
                target: item,
                callback: function(result) {
                    if (result.success) {
                        item.identified = true;
                        // TODO: Reveal BUC status, enchantments, etc.
                        Game.addMessage(`You identify the ${item.name}!`, 'success');
                    } else {
                        Game.addMessage("The item's nature remains mysterious.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // QUAFF - Drink potion
        Game.playerQuaff = function(potion) {
            if (!potion || potion.type !== 'potion') {
                Game.addMessage("That's not a potion!", 'warning');
                return;
            }
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'chemistry',  // Note: Need to add chemistry questions
                startingTier: potion.quiz_tier || 1,
                threshold: potion.quaff_threshold || 2,
                reason: `Drinking ${potion.name}`,
                target: potion,
                callback: function(result) {
                    if (result.success) {
                        // TODO: Apply potion effects
                        Game.addMessage(`You drink the ${potion.name}!`, 'success');
                        Game.player.removeFromInventory(potion);
                    } else {
                        Game.addMessage("You fail to drink it properly and it spills!", 'warning');
                        Game.player.removeFromInventory(potion);
                    }
                    Game.processTurn();
                }
            });
        };

        // LOCKPICK - Open containers or doors
        Game.playerLockpick = function(target) {
            if (!target || (!target.locked && target.type !== 'door')) {
                Game.addMessage("That's not locked!", 'info');
                return;
            }
            
            const threshold = target.lock_difficulty || Game.Dice.roll('2d4');  // 2-8
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'economics',
                startingTier: target.lock_tier || 1,
                threshold: threshold,
                reason: `Picking lock`,
                target: target,
                callback: function(result) {
                    if (result.success) {
                        target.locked = false;
                        Game.addMessage("You pick the lock successfully!", 'success');
                        
                        // Check for traps (50% chance on containers)
                        if (target.type === 'container' && Math.random() < 0.5) {
                            Game.addMessage("It was trapped! You take damage!", 'danger');
                            Game.player.takeDamage(Game.Dice.roll('2d6'));
                        }
                    } else {
                        Game.addMessage("You fail to pick the lock.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        // PRAY - Divine intervention
        Game.playerPray = function() {
            // TODO: Check if at altar or if enough time has passed
            
            Game.QuizEngine.startQuiz({
                mode: 'threshold',
                subject: 'theology',  // Note: Need to add theology questions
                startingTier: 1,
                threshold: 3,
                reason: 'Praying for divine aid',
                callback: function(result) {
                    if (result.success) {
                        // TODO: Random beneficial effect
                        Game.addMessage("You feel the presence of the divine!", 'success');
                    } else {
                        Game.addMessage("Your prayers go unanswered.", 'warning');
                    }
                    Game.processTurn();
                }
            });
        };

        Game.dropCorpse = function(monster) {
            const loot = Game.dropMonsterLoot(monster);
            Game.items.push(...loot);
            
            loot.forEach(item => {
                if (item.itemClass === 'corpses') {
                    Game.addMessage(`The ${monster.name} leaves a corpse.`, 'info');
                } else if (item.itemClass === 'currency') {
                    Game.addMessage(`You see ${item.name} here!`, 'loot');
                } else {
                    Game.addMessage(`You see a ${item.name} here!`, 'loot');
                }
            });
        };

        Game.pickupItem = function() {
            const player = Game.player;
            const itemsHere = Game.items.filter(i => i.x === player.x && i.y === player.y);
            
            if (itemsHere.length === 0) {
                Game.addMessage("There's nothing here to pick up.", 'info');
                return;
            }
            
            const item = itemsHere[0];
            if (player.addToInventory(item)) {
                Game.items = Game.items.filter(i => i !== item);
                Game.addMessage(`You pick up the ${item.name}.`, 'action');
            }
        };

        Game.nextLevel = function() {
            // Save current level before leaving
            Game.saveCurrentLevel();
            
            Game.currentLevel++;
            Game.addMessage(`You descend to level ${Game.currentLevel}...`, 'action');
            
            // Check if we've been here before
            if (!Game.loadLevel(Game.currentLevel)) {
                // Generate new level if first visit
                Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);
                
                // Track deepest level
                if (Game.currentLevel > Game.maxLevelReached) {
                    Game.maxLevelReached = Game.currentLevel;
                }
                
                // Spawn monsters for new level
                Game.monsters = [];
                const monsterBudget = 3 + Math.floor(Math.random() * 5) + Math.floor(Game.currentLevel / 5);
                for (let i = 0; i < monsterBudget; i++) {
                    const spawnedMonsters = Game.spawnMonster(Game.currentLevel, 1, 'dungeon');
                    if (spawnedMonsters) {
                        Game.monsters.push(...spawnedMonsters);
                    }
                }
                
                // Fresh FOV for new level
                Game.remembered = [];
            } else {
                Game.addMessage("You return to familiar territory.", 'info');
            }
            
            render();
        };

        Game.prevLevel = function() {
            if (Game.currentLevel <= 1) {
                Game.addMessage("You can't go up from here!", 'warning');
                return;
            }
            
            // Save current level
            Game.saveCurrentLevel();
            
            Game.currentLevel--;
            Game.addMessage(`You ascend to level ${Game.currentLevel}...`, 'action');
            
            // Load the previous level (it must exist since we came from there)
            if (!Game.loadLevel(Game.currentLevel)) {
                Game.addMessage("ERROR: Previous level not found!", 'danger');
                return;
            }
            
            render();
        };

        Game.attemptExit = function() {
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            
            const modal = document.getElementById('exit-modal');
            const message = document.getElementById('exit-message');
            
            if (hasStone) {
                message.innerHTML = `
                    <strong style="color: var(--gold-bright);">You possess the Philosopher's Stone!</strong><br><br>
                    Leaving now will complete your quest successfully.<br>
                    Your journey will end in VICTORY.<br><br>
                    Do you wish to leave the dungeon?
                `;
            } else {
                message.innerHTML = `
                    <strong style="color: var(--health-red);">You do not have the Philosopher's Stone!</strong><br><br>
                    Leaving now will end your quest in failure.<br>
                    Your journey will end in DEFEAT.<br><br>
                    Do you still wish to leave the dungeon?
                `;
            }
            
            modal.classList.add('active');
        };

        Game.confirmExit = function() {
            document.getElementById('exit-modal').classList.remove('active');
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            
            if (hasStone) {
                Game.victory();
            } else {
                Game.gameOver("You fled the dungeon without the Philosopher's Stone.");
            }
        };

        Game.cancelExit = function() {
            document.getElementById('exit-modal').classList.remove('active');
            Game.addMessage("You decide to continue your quest.", 'info');
        };

        Game.victory = function() {
            document.getElementById('victory-modal').classList.add('active');
            // Remove all other event handlers
            document.removeEventListener('keydown', Game.handleKeyPress);
        };

        Game.showScoreboard = function() {
            // Hide victory modal if showing
            document.getElementById('victory-modal').classList.remove('active');
            
            const modal = document.getElementById('scoreboard-modal');
            const result = document.getElementById('score-result');
            const content = document.getElementById('scoreboard-content');
            
            const hasStone = Game.player.inventory.some(item => item.id === 'philosophers_stone');
            result.innerHTML = hasStone ? 
                '<span style="color: var(--gold-bright);">QUEST COMPLETE - VICTORY!</span>' : 
                '<span style="color: var(--health-red);">QUEST FAILED</span>';
            
            // Calculate score
            const score = Game.calculateScore();
            
            content.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Journey Statistics</h3>
                        <div class="score-line">Turns Survived: <span>${Game.turn}</span></div>
                        <div class="score-line">Deepest Level: <span>${Game.maxLevelReached}</span></div>
                        <div class="score-line">Monsters Slain: <span>${Game.getMonstersKilled()}</span></div>
                        <div class="score-line">Items Collected: <span>${Game.player.inventory.length}</span></div>
                        <div class="score-line">Knowledge Used: <span>${Game.getQuestionsAnswered()}</span></div>
                    </div>
                    <div>
                        <h3 style="color: var(--gold-bright); margin-bottom: 10px;">Final Attributes</h3>
                        <div class="score-line">Strength: <span>${Game.player.strength}</span></div>
                        <div class="score-line">Constitution: <span>${Game.player.constitution}</span></div>
                        <div class="score-line">Dexterity: <span>${Game.player.dexterity}</span></div>
                        <div class="score-line">Intelligence: <span>${Game.player.intelligence}</span></div>
                        <div class="score-line">Wisdom: <span>${Game.player.wisdom}</span></div>
                        <div class="score-line">Perception: <span>${Game.player.perception}</span></div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 30px;">
                    <h2 style="color: var(--gold-bright);">FINAL SCORE: ${score}</h2>
                </div>
            `;
            
            modal.classList.add('active');
        };

        Game.calculateScore = function() {
            let score = 0;
            score += Game.turn * 10;
            score += Game.maxLevelReached * 1000;
            score += Game.getMonstersKilled() * 100;
            if (Game.player.inventory.some(item => item.id === 'philosophers_stone')) {
                score += 50000; // Huge bonus for winning
            }
            return score;
        };

        Game.getMonstersKilled = function() {
            return Object.values(Game.extinctions).reduce((sum, count) => sum + count, 0);
        };

        Game.getQuestionsAnswered = function() {
            // This would need to be tracked, for now return estimate
            return Game.getMonstersKilled() * 3; // Rough estimate
        };

        Game.gameOver = function(message) {
            Game.addMessage("=== GAME OVER ===", 'danger');
            Game.addMessage(message, 'danger');
            document.removeEventListener('keydown', Game.handleKeyPress);
            
            // Show scoreboard after a delay
            setTimeout(() => {
                Game.showScoreboard();
            }, 2000);
        };

        // ===== INITIALIZATION =====
        Game.init = function() {
            // Setup welcome screen
            const nameInput = document.getElementById('player-name-input');
            const startBtn = document.getElementById('start-game-btn');
            
            nameInput.focus();
            
            // Handle Enter key on name input
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    Game.startGame();
                }
            });
            
            startBtn.addEventListener('click', Game.startGame);
        };

        Game.startGame = async function() {
            const nameInput = document.getElementById('player-name-input');
            const playerName = nameInput.value.trim() || 'Hero';
            
            // Hide welcome, show game
            document.getElementById('welcome-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            // Get display element
            Game.display = document.getElementById('game-display');
            
            // Load monster data
            await Game.loadMonsterData();
            
            // Load item data
            await Game.loadItemData();

            // LOAD QUESTIONS:
            await Game.QuizEngine.loadAllQuestions();

            // Create player
            Game.player = new Player(playerName);
            
            // Generate first dungeon (without monsters)
            Game.dungeon = generateDungeon(Game.config.mapWidth, Game.config.mapHeight);

            // Now spawn monsters after dungeon exists
            Game.monsters = [];
            const monsterBudget = 3 + Math.floor(Math.random() * 5);
            for (let i = 0; i < monsterBudget; i++) {
                const spawnedMonsters = Game.spawnMonster(Game.currentLevel, 1, 'dungeon');
                if (spawnedMonsters) {
                    Game.monsters.push(...spawnedMonsters);
                }
            }
            
            // Setup input
            document.addEventListener('keydown', Game.handleKeyPress);
            
            // Initial messages
            Game.addMessage(`Welcome, ${playerName}, to the Philosopher's Quest!`, 'success');
            Game.addMessage("Knowledge is power. Every action requires learning.", 'info');
            Game.addMessage("Press ? for help.", 'info');
            
            // Initial render
            render();
        };

        // Quiz modal event handlers
        document.getElementById('quiz-submit').addEventListener('click', function() {
            const answer = document.getElementById('quiz-answer').value;
            if (answer && Game.QuizEngine.isActive) {
                Game.QuizEngine.handleAnswer(answer);
            }
        });

        document.getElementById('quiz-answer').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const answer = e.target.value;
                if (answer && Game.QuizEngine.isActive) {
                    Game.QuizEngine.handleAnswer(answer);
                }
            }
        });

        // Start when page loads
        window.addEventListener('load', Game.init);
    </script>
</body>
</html>